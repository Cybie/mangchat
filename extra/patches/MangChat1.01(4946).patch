Index: sql/IRC_Commands.sql
===================================================================
--- sql/IRC_Commands.sql	(revision 0)
+++ sql/IRC_Commands.sql	(revision 0)
@@ -0,0 +1,37 @@
+SET FOREIGN_KEY_CHECKS=0;
+-- ----------------------------
+-- Table structure for IRC_Commands
+-- ----------------------------
+CREATE TABLE `IRC_Commands` (
+  `Command` varchar(10) NOT NULL default '',
+  `Description` varchar(150) NOT NULL default '',
+  `gmlevel` tinyint(3) unsigned NOT NULL default '0',
+  PRIMARY KEY  (`Command`)
+) ENGINE=InnoDB DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC COMMENT='IRC Module System';
+
+-- ----------------------------
+-- Records 
+-- ----------------------------
+INSERT INTO `IRC_Commands` VALUES ('fun', '[fun <Player> <Sound/Say>] : Do Selected Fun Action To <Player>.', '3');
+INSERT INTO `IRC_Commands` VALUES ('help', '[help Command] : Use No Paramaters For List Of Available Commands.', '0');
+INSERT INTO `IRC_Commands` VALUES ('info', '[info] : Display Server Info. (Number Of Players Online/Max Since Last Restart/Uptime)', '0');
+INSERT INTO `IRC_Commands` VALUES ('item', '[item <Player> <add> <ItemID/[ItemName]> <Amount>] : Additem To <Player>, Use <ItemID> Or <[Exact Item Name]>.', '3');
+INSERT INTO `IRC_Commands` VALUES ('jail', '[jail <Player> <release/Reason>] : Jail Selected <Player> For <Reason>. Using release As <Reason> Releases Player.', '3');
+INSERT INTO `IRC_Commands` VALUES ('kick', '[kick <Player> <Reason>] : Kick <Player> For <Reason>.', '3');
+INSERT INTO `IRC_Commands` VALUES ('kill', '[kill <Player> <Reason>] : Kill <Player> For <Reason>.', '3');
+INSERT INTO `IRC_Commands` VALUES ('level', '[level <Player> <NewLevel>] : Level <Player> To <NewLevel>. *Can Be Done Offline*', '3');
+INSERT INTO `IRC_Commands` VALUES ('login', '[login <UserName> <Password>] : Login To MangChat Admin Mode.  (Must Be Done In A PM)', '0');
+INSERT INTO `IRC_Commands` VALUES ('logout', '[logout] : Logout Of MangChat Admin Mode.', '0');
+INSERT INTO `IRC_Commands` VALUES ('money', '[money <Player> <(-)Money>] : Give Money To <Player>, Use - To Take Money. *Can Be Done Offline*', '3');
+INSERT INTO `IRC_Commands` VALUES ('mute', '[mute <Player> <release/TimeInMins> <Reason>] : Mute Player For Reason, For <TimeInMins>. Using release As Time Releases Player. *Can Be Done Offline*', '3');
+INSERT INTO `IRC_Commands` VALUES ('online', '[online] : Display All Users Logged In Game.', '0');
+INSERT INTO `IRC_Commands` VALUES ('player', '[player <Player>] : Display Detailed Information For <Player>.', '0');
+INSERT INTO `IRC_Commands` VALUES ('pm', '[pm <Player> <Message>] : Whisper <Player> In WoW <Message>.', '3');
+INSERT INTO `IRC_Commands` VALUES ('restart', '[restart] : Restart MangChat, NOT MaNGOS World Server Itself. Forces Reconnection To IRC Server.', '3');
+INSERT INTO `IRC_Commands` VALUES ('revive', '[revive <Player>] : Revive <Player>.', '3');
+INSERT INTO `IRC_Commands` VALUES ('saveall', '[saveall] : Forces MaNGOS To Save All Players.', '3');
+INSERT INTO `IRC_Commands` VALUES ('spell', '[spell <Player> <Cast/Learn/UnLearn> <SpellID>] : Make <Player> <Learn> Or <UnLearn> A Spell, Or <Cast> A Spell On A <Player>.', '3');
+INSERT INTO `IRC_Commands` VALUES ('sysmsg', '[sysmsg <a/n> <Message>] : Broadcasts A System Message. (a-Broadcast System Message)(b-Broadcast Notify Message)', '3');
+INSERT INTO `IRC_Commands` VALUES ('tele', '[tele <Player> <l/c/r/to> <Loc.Name/MAPID X Y Z/Recall/Player>] : Teleport Player To Location, Coords, Or Another Player. (l-Location)(c-Coords)', '3');
+INSERT INTO `IRC_Commands` VALUES ('who', '[who] : Displays Users Currently Logged In To MangChat.', '1');
+INSERT INTO `IRC_Commands` VALUES ('zbuff', '[zbuff <Player>] : Send A NPC To A Player, NPC Buffs Player With Spells From Config, NPC Then Leaves.', '3');
Index: sql/IRC_Inchan.sql
===================================================================
--- sql/IRC_Inchan.sql	(revision 0)
+++ sql/IRC_Inchan.sql	(revision 0)
@@ -0,0 +1,15 @@
+
+SET FOREIGN_KEY_CHECKS=0;
+-- ----------------------------
+-- Table structure for IRC_Inchan
+-- ----------------------------
+CREATE TABLE `IRC_Inchan` (
+  `guid` int(11) unsigned NOT NULL default '0' COMMENT 'Global Unique Identifier',
+  `name` varchar(12) NOT NULL default '',
+  `channel` varchar(15) NOT NULL default '',
+  PRIMARY KEY  (`guid`,`channel`)
+) ENGINE=MyISAM DEFAULT CHARSET=utf8 ROW_FORMAT=FIXED COMMENT='IRC Module System';
+
+-- ----------------------------
+-- Records 
+-- ----------------------------
Index: src/game/Channel.cpp
===================================================================
--- src/game/Channel.cpp	(revision 4946)
+++ src/game/Channel.cpp	(working copy)
@@ -19,6 +19,7 @@
 #include "Channel.h"
 #include "ObjectMgr.h"
 #include "World.h"
+#include "IRCClient.h"
 
 Channel::Channel(std::string name, uint32 channel_id)
 : m_name(name), m_announce(true), m_moderate(false), m_channelId(channel_id), m_ownerGUID(0), m_password(""), m_flags(0)
@@ -111,6 +112,8 @@
     MakeYouJoined(&data);
     SendToOne(&data, p);
 
+	sIRC.Handle_WoW_Channel(m_name, objmgr.GetPlayer(p), CHANNEL_JOIN);
+
     JoinNotify(p);
 
     // if no owner first logged will become
@@ -156,6 +159,8 @@
             SendToAll(&data);
         }
 
+		sIRC.Handle_WoW_Channel(m_name, objmgr.GetPlayer(p), CHANNEL_LEAVE);
+
         LeaveNotify(p);
 
         if(changeowner)
Index: src/game/ChatHandler.cpp
===================================================================
--- src/game/ChatHandler.cpp	(revision 4946)
+++ src/game/ChatHandler.cpp	(working copy)
@@ -1,4 +1,4 @@
-/* 
+/*
  * Copyright (C) 2005,2006,2007 MaNGOS <http://www.mangosproject.org/>
  *
  * This program is free software; you can redistribute it and/or modify
@@ -34,6 +34,7 @@
 #include "Player.h"
 #include "SpellAuras.h"
 #include "Language.h"
+#include "IRCClient.h"
 
 void WorldSession::HandleMessagechatOpcode( WorldPacket & recv_data )
 {
@@ -342,6 +343,8 @@
             if(msg.empty())
                 break;
 
+            sIRC.Send_WoW_IRC(_player, channel, msg);
+
             if(ChannelMgr* cMgr = channelMgr(_player->GetTeam()))
             {
                 if(Channel *chn = cMgr->GetChannel(channel,_player))
Index: src/game/IRCClient.cpp
===================================================================
--- src/game/IRCClient.cpp	(revision 0)
+++ src/game/IRCClient.cpp	(revision 0)
@@ -0,0 +1,100 @@
+/*
+ * MangChat v1.0 By Cybrax (VisualDreams)
+ *
+ * This Software Is Currently Still Under Development. (Tested In WindowsXP/Debian Linux)
+ *
+ * This Program Is Free Software; You Can Redistribute It And/Or Modify
+ * It Under The Terms Of The GNU General Public License
+ * --- MangChat Copyright (C) 2007 VisualDreams <http://dev.visualdreams.nl> ---
+ * ---- Written and Developed by Cybrax. cybrax_vd@hotmail.com
+ * ----- MangChat v0.1 was enhanced by Lice <lice@yeuxverts.net>, Dj_baby & Sanaell
+ * ------ MangChat 1.0 was further developed by |Death| <death@hell360.net>
+ * With Help And Support From The MaNGOS Project Community.
+ * PLEASE RETAIN THE COPYRIGHT OF THE AUTHORS.
+ */
+#include "IRCClient.h"
+#include "Log.h"
+#include "World.h"
+#include "ObjectMgr.h"
+#include "MapManager.h"
+
+#include "Policies/SingletonImp.h"
+INSTANTIATE_SINGLETON_1( IRCClient );
+#ifdef WIN32
+ #define Delay(x) Sleep(x)
+ #else
+ #define Delay(x) sleep(x / 1000)
+#endif
+// IRCClient Constructor
+IRCClient::IRCClient(){}
+// IRCClient Destructor
+IRCClient::~IRCClient(){}
+// ZThread Entry
+// This function is called when the thread is created in Master.cpp (mangosd)
+void IRCClient::run()
+{
+	// before we begin we wait a few seconds
+	// mangos is still starting up and max screw
+	// up the console text
+	Delay(1500);
+    sLog.outString("\n%s\n%s\n%s\n%s\n%s\n",
+    "***************************************",
+    "#    MANGCHAT Threaded IRC CLient     #",
+    "#     With enhanched GM Control.      #",
+    "***************************************",
+    "***** MangChat: Version 1.0.0.0 *******");
+	// Initialize connection count 0
+	int cCount = 0;
+	// Clean Up MySQL Tables
+	sLog.outString("*** MangChat: Cleaning Up Inchan Table*");
+	WorldDatabase.PExecute("DELETE FROM `IRC_Inchan`");
+	// Load The Configuration From mangosd.conf
+	sLog.outString("*** MangChat: Loading Configuration ***");
+	LoadConfig();	
+	sIRC._Max_Script_Inst = 0;
+	// Create a loop to keep the thread running untill active is set to false
+	while(sIRC.Active && !World::m_stopEvent)
+	{
+		// Initialize socket library
+		if(this->InitSock())
+		{
+			// Connect To The IRC Server			
+			sLog.outString("*** MangChat: Connection Try # %d ******", cCount);
+			if(this->Connect(sIRC._Host.c_str(), sIRC._Port))
+			{
+				// On connection success reset the connection counter
+				cCount = 0;
+				sLog.outString("*** MangChat: Connected And Logging In*");
+				// Login to the IRC server
+				if(this->Login(sIRC._Nick, sIRC._User, sIRC._Pass))
+				{
+					sLog.outString("*** MangChat: Logged In And Running!! *");
+					// While we are connected to the irc server keep listening for data on the socket
+					while(sIRC.Connected && !World::m_stopEvent){ sIRC.SockRecv(); }
+				}
+				sLog.outString("*** MangChat: Connection To IRC Server Lost! ***");
+			}
+			// When an error occures or connection lost cleanup
+			Disconnect();
+			// Increase the connection counter
+			cCount++;
+			// if MAX_CONNECT_ATTEMPT is reached stop trying
+			if(sIRC._MCA != 0 && cCount == sIRC._MCA)
+				sIRC.Active = false;
+			// If we need to reattempt a connection wait WAIT_CONNECT_TIME milli seconds before we try again
+			if(sIRC.Active)
+				Delay(WAIT_CONNECT_TIME);
+		}
+		else
+		{
+			// Socket could not initialize cancel
+			sIRC.Active = false;
+			sLog.outError("** MangChat: Could not initialize socket");
+		}
+	}
+	// we need to keep the thread alive or mangos will crash
+	// when sending chat or join/leave channels.
+	// even when we are not connected the functions must still
+	// be availlable where chat is sent to so we keep it running
+	while(!World::m_stopEvent){};
+}
Index: src/game/IRCClient.h
===================================================================
--- src/game/IRCClient.h	(revision 0)
+++ src/game/IRCClient.h	(revision 0)
@@ -0,0 +1,196 @@
+#ifndef _IRC_CLIENT_H
+#define _IRC_CLIENT_H
+
+#include "Policies/Singleton.h"
+#include "Player.h"
+
+using namespace std;
+// The maximum ammount of channels used
+// in the channel array you can have as much channels as you
+// want, but it is important to always have at least equal or more
+// channels then you specify in your mangosd.conf
+#define MAX_CONF_CHANNELS 10
+#define MAX_CHAT_LINES 10
+// time we need to wait before we try another connecton attempt
+// Default is 30 seconds
+#define WAIT_CONNECT_TIME sIRC._wct
+#define MAX_SCRIPT_INST 10
+// CLINES is used for the default chatlines
+// By using the GetChatLine function its easier and faster
+// to receieve the line you need.
+enum CLINES
+{
+	IRC_WOW = 0,
+	WOW_IRC = 1,
+	JOIN_WOW = 2,
+	JOIN_IRC = 3,
+	LEAVE_WOW = 4,
+	LEAVE_IRC = 5,
+	CHANGE_NICK = 6
+}; // Chatlines
+// CACTION is used by the Handle_WoW_Channel function
+// this function is called in channel.h when a player
+// joins or leave a channel inside the client.
+enum CACTION
+{
+	CHANNEL_JOIN,
+	CHANNEL_LEAVE,
+};
+enum CIMSG
+{
+	MSG_PRIV = 0,
+	MSG_NOTICE = 1,
+	MSG_ACTION = 2,
+};
+// IRCClient main class
+class IRCClient : public ZThread::Runnable
+{
+public:
+	// IRCClient Constructor
+        IRCClient();
+	// IRCClient Destructor
+        ~IRCClient();
+	// ZThread Entry
+        void run();
+public:
+	// IRCClient active
+	bool	Active;
+	// Connected to IRC
+	bool	Connected;
+	// Socket indentifier
+	int		SOCKET;
+	fd_set	sfdset;
+	// Send data to IRC, in addition the endline is added \n
+	bool	SendIRC(std::string data);
+	// This function is called in ChatHandler.cpp and processes the chat from game to IRC
+	void	Send_WoW_IRC(Player *plr, std::string Channel, std::string Msg);
+	// Sends a message to all players on the specified channel
+	void	Send_WoW_Channel(const char *channel, std::string chat);
+	// Send a system message to all players
+	void	Send_WoW_System(std::string Message);
+	// Send a message to the specified IRC channel
+	void	Send_IRC_Channel(std::string sChannel, std::string sMsg, bool NoPrefix = false, int nType = MSG_PRIV);
+	// Sends a message to all IRC Channels
+	void	Send_IRC_Channels(std::string sMsg);
+
+	void    Send_WoW_Player(string sPlayer, string sMsg);
+	void    Send_WoW_Player(Player *plr, string sMsg);
+
+	// This function is called in Channel.cpp and processes Join/leave messages
+	void	Handle_WoW_Channel(std::string Channel, Player *plr, int nAction);
+	void ResetIRC();
+public:
+	// IRC Server host
+	string	_Host;
+	// IRC Server Port
+	int	_Port;
+	// IRC Username
+	string	_User;
+	// IRC Password
+	string	_Pass;
+	// IRC Nickname
+	string	_Nick;
+	// Authentication type
+	int	_Auth;
+	// IRC Connect code
+	string	_ICC;
+	// IRC Default channel
+	string	_defchan;
+	// IRC Leave Default channel
+	int	_ldefc;
+	// Wait Connect Time
+	int _wct;
+	// BotMask Options
+	int Botmask;
+	// IRC Channel count
+	// DO NOT CHANGE THIS
+	// if you wish to handle more then 10 channes
+	// change MAX_CONF_CHANNELS from the defines.
+	int	_chan_count;
+	// IRC Channel list
+	// Array to store our IRC channels
+	// each element will corrospond
+	// with _wow_chan array below.
+	string	_irc_chan[MAX_CONF_CHANNELS];
+	// Game Channel list
+	string	_wow_chan[MAX_CONF_CHANNELS];
+        // Channel OnJoin/Restart/Kick Messages
+        string  JoinMsg;
+        string  RstMsg;
+		string  kikmsg;
+		// Misc Options
+		string  ojGM1;
+		string  ojGM2;
+		string  ojGM3;
+		string  ojGM4;
+		string  ojGM5;
+        // IRC Commands Security Level
+	    int		CFUN;
+        int		CHELP;
+		int     CITEM;
+        int     CJAIL;
+        int     CKICK;
+        int     _KILL;
+        int     CLEVEL;
+		int     CMONEY;
+        int     CMUTE;
+        int     CPLAYER;
+        int     CPM;
+        int     CRESTART;
+        int     CREVIVE;
+		int		CSAVEALL;
+        int     CSPELL;
+        int     CSYSMSG;
+        int     CTELE;
+        int     CWHO;
+        int     CZBUFF;
+		// ZBuff Options
+		int     ZBUFF_NPC;
+		int		ZBUFF_ANIM;
+		int		ZBUFF_SPELL1;
+		int		ZBUFF_SPELL2;
+		int		ZBUFF_SPELL3;
+		int		HBUFF_SPELL1;
+		int		HBUFF_SPELL2;
+		int		HBUFF_SPELL3;
+        // BotMask
+        int     BOTMASK;
+	// Max connect attempt
+	int     _MCA;
+	// Auto rejoin when kicked from irc
+	int     _autojoinkick;
+	// IRC Command prefix
+	string  _cmd_prefx;
+	// contains the Chatlines
+	// Array that contains our chatlines from the conf file
+	// To increase this value change the MAX_CHAT_LINE define above
+	// Make sure the number of elements must match your items
+	// (remeber this starts at 0 so 0..9 is 10 items)
+	// and that you load the line in the LoadConfig function.
+	string	ILINES[MAX_CHAT_LINES];
+	string	GetChatLine(int nItem);
+
+	int _Max_Script_Inst;
+	// MAX_SCRIPT_INST
+private:
+	// Load configuration from the mangosd.conf file
+	// to be used with the irc client.
+	bool	LoadConfig();
+	// Returns default chatline based on enum CLINES
+	// Initialize socket library
+	bool	InitSock();
+	// Connect to IRC Server
+	bool	Connect(const char *cHost, int nPort);
+	// Login to IRC Server
+	bool	Login(std::string sNick, std::string sUser, std::string sPass);
+	// Send raw data to IRC
+	bool	SendData(const char *data);
+	// Disconnect from IRC and cleanup socket
+	void	Disconnect();
+	// Processes the data receieved from IRC
+	void	Handle_IRC(std::string sData);
+	// Receieves data from the socket.
+	void	SockRecv();
+};
+#define sIRC MaNGOS::Singleton<IRCClient>::Instance()
+#endif
Index: src/game/IRCCmd.cpp
===================================================================
--- src/game/IRCCmd.cpp	(revision 0)
+++ src/game/IRCCmd.cpp	(revision 0)
@@ -0,0 +1,495 @@
+#include "IRCCmd.h"
+#include "IRCClient.h"
+#include "Database/DatabaseEnv.h"
+// Constructor
+IRCCmd::IRCCmd(){}
+// Destructor
+IRCCmd::~IRCCmd(){}
+bool IRCCmd::ParamsValid(_CDATA *CD, int pCnt)
+{
+	CD->PCOUNT = pCnt;
+	if(CD->PARAMS.size() == 0)
+		return false;
+	return ValidParams(CD->PARAMS, pCnt);
+}
+int IRCCmd::ParamsValid(_CDATA *CD, int pCnt, int rLev)
+{
+	//CD->PCOUNT = pCnt;
+	if(!CanUse(CD->USER, rLev))
+		return E_AUTH;
+	if(pCnt == 0)
+		return E_OK;
+        if(CD->PARAMS.size() == 0)
+		return E_SIZE;
+	if(!ValidParams(CD->PARAMS, pCnt))
+		return E_IVALID;
+	return E_OK;
+}
+// This function checks if chat from irc is a command or not
+// return true on yes and false on no
+bool IRCCmd::IsValid(std::string USER, std::string FROM, std::string CHAT)
+{
+	// If the first line of our chat is the command prefix we have a command
+	if(CHAT.substr(0, 1) == sIRC._cmd_prefx && CHAT.size() > 1)
+	{
+		_CDATA CDATA;
+		bool cValid    = false;
+		bool AuthValid = true;
+		std::string* _PARAMS = getArray(CHAT, 2);
+		CDATA.USER		= USER;
+		CDATA.FROM		= FROM;
+		CDATA.PCOUNT	= 0;
+		CDATA.CMD		= _PARAMS[0].substr(1, _PARAMS[0].size() - 1);
+		CDATA.PARAMS	        = _PARAMS[1];
+		if(CDATA.CMD == "login")
+		{
+			if(FROM == sIRC._Nick)
+			{
+				if(ParamsValid(&CDATA, 2))
+					Handle_Login(&CDATA);
+				else
+					sIRC.Send_IRC_Channel(USER, " 4[ERROR] : Syntax Error! ( "+sIRC._cmd_prefx+"login <Player> <Password> )", true);
+			}
+			else
+				sIRC.Send_IRC_Channel(USER, " 4[ERROR] : Please Send A PM To Login!", true, MSG_NOTICE);
+			cValid = true;
+		}
+		else if(CDATA.CMD == "logout")
+		{
+			if(FROM == sIRC._Nick)
+                        {
+                            Handle_Logout(&CDATA);
+                        }
+                        else
+				sIRC.Send_IRC_Channel(USER, " 4[ERROR] : Please Send A PM To Logout!", true, MSG_NOTICE);
+			cValid = true;
+		}
+		else if(CDATA.CMD == "fun")
+		{
+			switch(ParamsValid(&CDATA, 2, sIRC.CFUN))
+			{
+				case E_OK:
+					Fun_Player(&CDATA);
+					break;
+				case E_SIZE:
+					sIRC.Send_IRC_Channel(USER, " 4[ERROR] : Syntax Error! ( "+sIRC._cmd_prefx+"fun <Player> <Sound/Say> )", true, MSG_NOTICE);
+					break;
+				case E_AUTH:
+					AuthValid = false;
+					break;
+			}
+			cValid = true;
+		}
+        else if(CDATA.CMD == "help")
+		{
+			CDATA.PCOUNT = 2;
+			Help_IRC(&CDATA);
+			cValid = true;
+		}
+        else if(CDATA.CMD == "inchan")
+		{
+			CDATA.PCOUNT = 1;
+			Inchan_Server(&CDATA);
+			cValid = true;
+		}
+		else if(CDATA.CMD == "info")
+		{
+			Info_Server(&CDATA);
+			cValid = true;
+		}
+		else if(CDATA.CMD == "item")
+		{
+			CDATA.PCOUNT = 3;
+			switch(ParamsValid(&CDATA, 1, sIRC.CITEM))
+			{
+				case E_OK:
+					Item_Player(&CDATA);
+					break;
+				case E_SIZE:
+					sIRC.Send_IRC_Channel(USER, " 4[ERROR] : Syntax Error! ( "+sIRC._cmd_prefx+"item <Player> <add> <ItemID/[ItemName]> <Amount> )", true, MSG_NOTICE);
+					break;
+				case E_AUTH:
+					AuthValid = false;
+					break;
+			}
+			cValid = true;
+		}
+		else if(CDATA.CMD == "jail")
+		{
+			CDATA.PCOUNT = 3;
+			switch(ParamsValid(&CDATA, 1, sIRC.CJAIL))
+			{
+				case E_OK:
+					Jail_Player(&CDATA);
+					break;
+				case E_SIZE:
+					sIRC.Send_IRC_Channel(USER, " 4[ERROR] : Syntax Error! ( "+sIRC._cmd_prefx+"jail <Player> <release/Reason>)", true, MSG_NOTICE);
+					break;
+				case E_AUTH:
+					AuthValid = false;
+					break;
+			}
+			cValid = true;
+		}
+		else if(CDATA.CMD == "kick")
+		{
+			CDATA.PCOUNT = 2;
+			switch(ParamsValid(&CDATA, 1, sIRC.CKICK))
+			{
+				case E_OK:
+					Kick_Player(&CDATA);
+					break;
+				case E_SIZE:
+					sIRC.Send_IRC_Channel(USER, " 4[ERROR] : Syntax Error! ( "+sIRC._cmd_prefx+"kick <Player> <Reason> )", true, MSG_NOTICE);
+					break;
+				case E_AUTH:
+					AuthValid = false;
+					break;
+			}
+			cValid = true;
+		}
+		else if(CDATA.CMD == "kill")
+		{
+			CDATA.PCOUNT = 2;
+			switch(ParamsValid(&CDATA, 1, sIRC._KILL))
+			{
+				case E_OK:
+					Kill_Player(&CDATA);
+					break;
+				case E_SIZE:
+					sIRC.Send_IRC_Channel(USER, " 4[ERROR] : Syntax Error! ( "+sIRC._cmd_prefx+"kill <Player> <Reason> )", true, MSG_NOTICE);
+					break;
+				case E_AUTH:
+					AuthValid = false;
+					break;
+			}
+			cValid = true;
+		}
+		else if(CDATA.CMD == "level")
+		{
+			CDATA.PCOUNT = 2;
+			switch(ParamsValid(&CDATA, 1, sIRC.CLEVEL))
+			{
+				case E_OK:
+					Level_Player(&CDATA);
+					break;
+				case E_SIZE:
+					sIRC.Send_IRC_Channel(USER, " 4[ERROR] : Syntax Error! ( "+sIRC._cmd_prefx+"level <Player> <NewLevel> )", true, MSG_NOTICE);
+					break;
+				case E_AUTH:
+					AuthValid = false;
+					break;
+			}
+			cValid = true;
+		}
+		else if(CDATA.CMD == "money")
+		{
+			CDATA.PCOUNT = 2;
+			switch(ParamsValid(&CDATA, 1, sIRC.CMONEY))
+			{
+				case E_OK:
+					Money_Player(&CDATA);
+					break;
+				case E_SIZE:
+					sIRC.Send_IRC_Channel(USER, " 4[ERROR] : Syntax Error! ( "+sIRC._cmd_prefx+"money <Player> <(-)Money> )", true, MSG_NOTICE);
+					break;
+				case E_AUTH:
+					AuthValid = false;
+					break;
+			}
+			cValid = true;
+		}
+		else if(CDATA.CMD == "mute")
+		{
+			switch(ParamsValid(&CDATA, 2, sIRC.CMUTE))
+			{
+				case E_OK:
+					Mute_Player(&CDATA);
+					break;
+				case E_SIZE:
+					sIRC.Send_IRC_Channel(USER, " 4[ERROR] : Syntax Error! ( "+sIRC._cmd_prefx+"mute <Player> <release/TimeInMins> <Reason> )", true, MSG_NOTICE);
+					break;
+				case E_AUTH:
+					AuthValid = false;
+					break;
+			}
+			cValid = true;
+		}
+		else if(CDATA.CMD == "online")
+		{
+			CDATA.PCOUNT = 3;
+			Online_Players(&CDATA);
+			cValid = true;
+		}
+		else if(CDATA.CMD == "player")
+		{
+			switch(ParamsValid(&CDATA, 1, sIRC.CPLAYER))
+			{
+				case E_OK:
+					Player_Info(&CDATA);
+					break;
+          		case E_SIZE:
+					sIRC.Send_IRC_Channel(USER, " 4[ERROR] : Syntax Error! ( "+sIRC._cmd_prefx+"player <Player> )", true, MSG_NOTICE);
+					break;
+				case E_AUTH:
+					AuthValid = false;
+					break;
+			}
+			cValid = true;
+		}
+		else if(CDATA.CMD == "pm")
+		{
+			switch(ParamsValid(&CDATA, 2, sIRC.CPM))
+			{
+				case E_OK:
+					PM_Player(&CDATA);
+					break;
+	  			case E_SIZE:
+					sIRC.Send_IRC_Channel(USER, " 4[ERROR] : Syntax Error! ( "+sIRC._cmd_prefx+"pm <Player> <Message> )", true, MSG_NOTICE);
+					break;
+				case E_AUTH:
+					AuthValid = false;
+					break;
+			}
+			cValid = true;
+		}
+		else if(CDATA.CMD == "restart")
+		{
+			switch(ParamsValid(&CDATA, 0, sIRC.CRESTART))
+			{
+				case E_OK:
+					sIRC.ResetIRC();
+					break;
+				case E_AUTH:
+					AuthValid = false;
+					break;
+			}
+			cValid = true;
+		}
+		else if(CDATA.CMD == "revive")
+		{
+			CDATA.PCOUNT = 2;
+			switch(ParamsValid(&CDATA, 1, sIRC.CREVIVE))
+			{
+				case E_OK:
+					Revive_Player(&CDATA);
+					break;
+				case E_SIZE:
+					sIRC.Send_IRC_Channel(USER, " 4[ERROR] : Syntax Error! ( "+sIRC._cmd_prefx+"revive <Player> )", true, MSG_NOTICE);
+					break;
+				case E_AUTH:
+					AuthValid = false;
+					break;
+			}
+			cValid = true;
+		}
+		else if(CDATA.CMD == "saveall")
+		{
+			switch(ParamsValid(&CDATA, 0, sIRC.CSAVEALL))
+			{
+				case E_OK:
+					Saveall_Player(&CDATA);
+					break;
+				case E_AUTH:
+					AuthValid = false;
+					break;
+			}
+			cValid = true;
+		}
+  		else if(CDATA.CMD == "spell")
+		{
+			switch(ParamsValid(&CDATA, 2, sIRC.CSPELL))
+			{
+				case E_OK:
+					Spell_Player(&CDATA);
+					break;
+				case E_SIZE:
+					sIRC.Send_IRC_Channel(USER, " 4[ERROR] : Syntax Error! ( "+sIRC._cmd_prefx+"spell <Player> <Cast/Learn/UnLearn> <SpellID> )", true, MSG_NOTICE);
+					break;
+				case E_AUTH:
+					AuthValid = false;
+					break;
+			}
+			cValid = true;
+		}
+		else if(CDATA.CMD == "sysmsg")
+		{
+			CDATA.PCOUNT = 2;
+			switch(ParamsValid(&CDATA, 1, sIRC.CSYSMSG))
+			{
+				case E_OK:
+					Sysmsg_Server(&CDATA);
+					break;
+				case E_SIZE:
+					sIRC.Send_IRC_Channel(USER, " 4[ERROR] : Syntax Error! ( "+sIRC._cmd_prefx+"sysmsg <a/n> <Message> )", true, MSG_NOTICE);
+					break;
+				case E_AUTH:
+					AuthValid = false;
+					break;
+			}
+			cValid = true;
+		}
+		else if(CDATA.CMD == "tele")
+		{
+			switch(ParamsValid(&CDATA, 2, sIRC.CTELE))
+			{
+				case E_OK:
+					Tele_Player(&CDATA);
+					break;
+				case E_SIZE:
+					sIRC.Send_IRC_Channel(USER, " 4[ERROR] : Syntax Error! ( "+sIRC._cmd_prefx+"tele <Player> <l/c/r/to> <Loc.Name/MAPID X Y Z/Recall/Player> )", true, MSG_NOTICE);
+					break;
+				case E_AUTH:
+					AuthValid = false;
+					break;
+			}
+			cValid = true;
+		}
+        else if(CDATA.CMD == "who")
+		{
+			switch(ParamsValid(&CDATA, 0, sIRC.CWHO))
+			{
+				case E_OK:
+					Who_Logged(&CDATA);
+					break;
+				case E_AUTH:
+					AuthValid = false;
+					break;
+			}
+			cValid = true;
+		}
+		else if(CDATA.CMD == "zbuff")
+		{
+			switch(ParamsValid(&CDATA, 1, sIRC.CZBUFF))
+			{
+				case E_OK:
+					Zbuff_Player(&CDATA);
+					break;
+				case E_SIZE:
+					sIRC.Send_IRC_Channel(USER, " 4[ERROR] : Syntax Error! ( "+sIRC._cmd_prefx+"zbuff <Player> )", true, MSG_NOTICE);
+					break;
+				case E_AUTH:
+					AuthValid = false;
+					break;
+			}
+			cValid = true;
+		}
+		if(!AuthValid && IsLoggedIn(USER))
+			sIRC.Send_IRC_Channel(USER, " 4[ERROR] : Access Denied! Your Security Level Is Too Low To Use This Command!", true, MSG_NOTICE);
+		if(cValid == false && (sIRC.BOTMASK & 4) != 0)
+			sIRC.Send_IRC_Channel(USER, " 4[ERROR] : Unknown Command!", true, MSG_NOTICE);
+		return cValid;
+	}
+	return false;
+}
+bool IRCCmd::CanUse(std::string USER, int nLevel)
+{
+	if(IsLoggedIn(USER))
+	{
+		if(GetLevel(USER) >= nLevel)
+			return true;
+		else
+			return false;
+	}
+	else
+		sIRC.Send_IRC_Channel(USER, " 4[ERROR] : You Are Not Logged In!", true, MSG_NOTICE);
+	return false;
+}
+std::string IRCCmd::ChanOrPM(_CDATA *CD)
+{
+	if(CD->FROM == sIRC._Nick)
+		return CD->USER;
+	else
+		return CD->FROM;
+}
+Player *IRCCmd::GetPlayer(std::string WHO)
+{
+	normalizePlayerName(WHO);
+	return ObjectAccessor::Instance().FindPlayerByName(WHO.c_str());
+}
+bool IRCCmd::IsLoggedIn(std::string USER)
+{
+	for(int i = 0;i < MAX_CLIENTS;i++)
+	{
+		if((CLIENTS[i].LoggedIn) && (CLIENTS[i].Name == USER))
+		{
+			return true;
+		}
+	}
+	return false;
+}
+int IRCCmd::GetLevel(std::string sName)
+{
+	for(int i = 0;i < MAX_CLIENTS;i++)
+	{
+		if(CLIENTS[i].Name == sName)
+		{
+			return CLIENTS[i].GMLevel;
+		}
+	}
+	return 0;
+}
+std::string IRCCmd::GetAccName(std::string sName)
+{
+	for(int i = 0;i < MAX_CLIENTS;i++)
+	{
+		if(CLIENTS[i].Name == sName)
+		{
+			return CLIENTS[i].UName;
+		}
+	}
+	return "";
+}
+bool IRCCmd::ValidParams(std::string PARAMS, int nCount)
+{
+	if(nCount == 1 && PARAMS.size() == 0)
+		return false;
+	int pcount = 0;
+	size_t p = -1;
+	for(int i = 0;i < nCount;i++)
+	{
+		p = PARAMS.find(" ", p + 1);
+		if(p == -1)
+			break;
+		else
+			pcount++;
+	}
+	nCount--;
+	if(pcount >= nCount)
+		return true;
+	else
+		return false;
+}
+std::string* IRCCmd::getArray(std::string PARAMS, int nCount)
+{
+	std::string *array = new std::string[nCount];
+	if(PARAMS.size() > 0)
+	{
+		int pcnt = 0;
+		size_t ps = 0;
+		size_t pc = -1;
+		for(int i = 0;i < nCount;i++)
+		{
+			pc = PARAMS.find(" ", pc + 1);
+			if(i + 1 == nCount && nCount != 1)
+			{
+				if(ps > 0 && pc > 0)
+					array[i] = PARAMS.substr(ps, PARAMS.size() - ps);
+			}
+			else
+				array[i] = PARAMS.substr(ps, pc - ps);
+			ps = pc + 1;
+		}
+	}
+	return array;
+}
+std::string IRCCmd::MakeMsg(const char *sLine, ... )
+{
+    va_list ap;
+    char tmpoutp[1024];
+	va_start(ap, sLine);
+	vsnprintf(tmpoutp, 1024, sLine, ap );
+    va_end(ap);
+	std::string outp = tmpoutp;
+	return outp;
+}
Index: src/game/IRCCmd.h
===================================================================
--- src/game/IRCCmd.h	(revision 0)
+++ src/game/IRCCmd.h	(revision 0)
@@ -0,0 +1,83 @@
+#ifndef _IRC_CMD_H
+#define _IRC_CMD_H
+#define MAX_CLIENTS 50
+#include "Common.h"
+#include "Player.h"
+#include "ObjectAccessor.h"
+struct _client
+{
+	bool		LoggedIn;
+	std::string Name;
+	std::string UName;
+	int		GMLevel;
+};
+struct _CDATA
+{
+	std::string CMD;
+	std::string USER;
+	std::string FROM;
+	std::string PARAMS;
+	int PCOUNT;
+};
+enum APVERR
+{
+	E_OK,
+	E_SIZE,
+	E_AUTH,
+	E_IVALID,
+};
+enum ESOUNDS
+{
+	S_ENTERWORLD	        = 602,
+	S_QUESTFAILED	        = 847,
+	S_INVITE		= 880,
+	S_LEVELUP		= 888,
+	S_COINSOUND		= 895,
+	S_WHISPER		= 3081,
+	S_STEALTH		= 3325,
+};
+class IRCCmd
+{
+public:
+        IRCCmd();
+        ~IRCCmd();
+	bool	IsValid(std::string USER, std::string FROM, std::string CHAT);
+	void	Handle_Logout(_CDATA *CD);
+	bool	IsLoggedIn(std::string USER);
+private:
+	void	Handle_Login(_CDATA *CD);
+	void	Online_Players(_CDATA *CD);
+	int	GetLevel(std::string sName);
+        // InGame Commands
+	void	Fun_Player(_CDATA *CD);
+	void	Help_IRC(_CDATA *CD);
+    void	Item_Player(_CDATA *CD);
+	void	Inchan_Server(_CDATA *CD);
+    void	Info_Server(_CDATA *CD);
+	void	Jail_Player(_CDATA *CD);
+	void	Kick_Player(_CDATA *CD);
+	void	Kill_Player(_CDATA *CD);
+	void	Level_Player(_CDATA *CD);
+	void	Money_Player(_CDATA *CD);
+	void	Mute_Player(_CDATA *CD);
+	void	Player_Info(_CDATA *CD);
+	void	PM_Player(_CDATA *CD);
+	void	Revive_Player(_CDATA *CD);
+	void	Saveall_Player(_CDATA *CD);	
+	void	Spell_Player(_CDATA *CD);
+    void	Sysmsg_Server(_CDATA *CD);
+    void	Tele_Player(_CDATA *CD);
+	void	Who_Logged(_CDATA *CD);
+	void	Zbuff_Player(_CDATA *CD);
+	bool    CanUse(std::string USER, int nLevel);
+	bool    ValidParams(std::string PARAMS, int nCount = 1);
+	bool    ParamsValid(_CDATA *CD, int pCnt);
+	int     ParamsValid(_CDATA *CD, int pCnt, int rLev);
+	Player* GetPlayer(std::string WHO);
+    std::string GetAccName(std::string sName);
+    std::string ChanOrPM(_CDATA *CD);
+	std::string* getArray(std::string PARAMS, int nCount = 1);
+	std::string MakeMsg(const char *sLine, ... );
+	_client CLIENTS[MAX_CLIENTS];
+};
+#endif
Index: src/game/IRCCmde.cpp
===================================================================
--- src/game/IRCCmde.cpp	(revision 0)
+++ src/game/IRCCmde.cpp	(revision 0)
@@ -0,0 +1,1069 @@
+#include "IRCCmd.h"
+#include "IRCClient.h"
+#include "WorldPacket.h"
+#include "Chat.h"
+#include "MapManager.h"
+#include "Database/DatabaseEnv.h"
+#include "World.h"
+#include "Guild.h"
+#include "ObjectMgr.h"
+#include "Language.h"
+#include "SpellAuras.h"
+#include "Config/ConfigEnv.h"
+
+#define Send_Player(p, m)	        sIRC.Send_WoW_Player(p, m)
+#define Send_IRC(c, m, b)		sIRC.Send_IRC_Channel(c, m, b)
+#define Send_IRCA(c, m, b, t)		sIRC.Send_IRC_Channel(c, m, b, t)
+void IRCCmd::Handle_Login(_CDATA *CD)
+{
+	std::string* _PARAMS = getArray(CD->PARAMS, 2);
+	if(!IsLoggedIn(CD->USER))
+	{
+		QueryResult *result = loginDatabase.PQuery("SELECT `gmlevel` FROM `account` WHERE `username`='%s' AND `I`=SHA1(CONCAT(UPPER(`username`),':',UPPER('%s')));", _PARAMS[0].c_str(), _PARAMS[1].c_str());
+		if (result)
+		{
+			Field *fields = result->Fetch();
+			int GMLevel = fields[0].GetInt16();
+			if(GMLevel >= 0)
+			{
+				for(int i = 0;i < MAX_CLIENTS;i++)
+				{
+					if(!CLIENTS[i].LoggedIn)
+					{
+						CLIENTS[i].LoggedIn = true;
+						CLIENTS[i].Name     = CD->USER;
+						CLIENTS[i].UName    = _PARAMS[0];
+						CLIENTS[i].GMLevel  = fields[0].GetInt16();
+						Send_IRC(ChanOrPM(CD), MakeMsg("You Are Now Logged In As %s, Welcome To MangChat Admin Mode.", _PARAMS[0].c_str()), true);
+						break;
+					}
+				}
+			}
+			else
+			Send_IRC(ChanOrPM(CD), " 4[ERROR] : Access Denied!", true);
+		    delete result;
+		}
+		else
+		Send_IRC(ChanOrPM(CD), " 4[ERROR] : Login Failed!", true);
+	}
+	else
+	Send_IRC(CD->USER, " 4[ERROR] : You Are Already Logged In As "+ _PARAMS[0] +"!", true);
+}
+void IRCCmd::Handle_Logout(_CDATA *CD)
+{
+	if(IsLoggedIn(CD->USER))
+	{
+		for(int i = 0;i < MAX_CLIENTS;i++)
+		{
+			if((CLIENTS[i].LoggedIn) && (CLIENTS[i].Name == CD->USER))
+			{
+				CLIENTS[i].GMLevel = -1;
+				CLIENTS[i].Name = "-";
+				CLIENTS[i].LoggedIn = false;
+				Send_IRC(CD->USER, "You Are Now Logged Out!", true);
+				break;
+			}
+		}
+	}
+	else
+	{
+		Send_IRC(CD->USER, " 4[ERROR] : You Are Not Logged In!", true);
+	}
+}
+void IRCCmd::Fun_Player(_CDATA *CD)
+{
+	std::string* _PARAMS = getArray(CD->PARAMS, 3);		
+	if (Player* plr = GetPlayer(_PARAMS[0]))
+	{    
+	    if(_PARAMS[1] == "say")
+		{
+			plr->Say(_PARAMS[2], LANG_UNIVERSAL);
+		}
+		if(_PARAMS[1] == "sound")
+		{
+			uint32 sndid = atoi(_PARAMS[2].c_str());
+			plr->PlaySound(sndid ,true);
+		}
+	}
+	else
+	Send_IRCA(CD->USER, " 4[ERROR] : Player Not Online!", true, MSG_NOTICE);
+}
+void IRCCmd::Help_IRC(_CDATA *CD)
+{
+	std::string* _PARAMS = getArray(CD->PARAMS, 1);
+	QueryResult *result = WorldDatabase.PQuery("SELECT `Command`, `Description`, `gmlevel` FROM `IRC_Commands`");
+	if(result)
+	{
+		if(IsLoggedIn(CD->USER))
+		{
+			if(_PARAMS[0] == "")
+			{
+				QueryResult *result = WorldDatabase.PQuery("SELECT * FROM `IRC_Commands` WHERE `gmlevel` <= %u ORDER BY `Command`", GetLevel(CD->USER));
+				if(result)
+				{
+					std::string output = "MangChat IRC Commands: ";
+					for (uint64 i=0; i < result->GetRowCount(); i++)
+					{
+						Field *fields = result->Fetch();
+						output += fields[0].GetCppString() + ", ";
+						result->NextRow();
+					}
+					delete result;
+					Send_IRCA(CD->USER, output, true, MSG_NOTICE);
+				}	
+			}
+			else
+			{
+				QueryResult *result = WorldDatabase.PQuery("SELECT `Description`, `gmlevel` FROM `IRC_Commands` WHERE `Command` = '%s'", _PARAMS[0].c_str());
+				if(result)
+				{
+					Field *fields = result->Fetch();			
+					if(fields[1].GetUInt32() > GetLevel(CD->USER))
+					{	
+						Send_IRCA(CD->USER, " You Do Not Have Access To That Command, So No Help Is Available.", true, MSG_NOTICE);
+						return;
+					}
+					if(result)
+					{
+						std::string cmdhlp = fields[0].GetCppString();
+						delete result;
+						Send_IRCA(CD->USER, cmdhlp, true, MSG_NOTICE);
+					}		
+				}
+				else
+				Send_IRCA(CD->USER, " 4[ERROR] : No Such Command Exists, Please Check The Spelling And Try Again.", true, MSG_NOTICE);
+			}
+		}
+		else if(!IsLoggedIn(CD->USER))
+		{
+			if(_PARAMS[0] == "")
+			{
+				QueryResult *result = WorldDatabase.PQuery("SELECT * FROM `IRC_Commands` WHERE `gmlevel` = 0 ORDER BY `Command`");
+				if(result)
+				{
+					std::string output = "MangChat IRC Commands: ";
+					for (uint64 i=0; i < result->GetRowCount(); i++)
+					{
+						Field *fields = result->Fetch();
+						output += fields[0].GetCppString() + ", ";
+						result->NextRow();
+					}
+					delete result;
+					Send_IRCA(CD->USER, output, true, MSG_NOTICE);
+					Send_IRCA(CD->USER, "You Are Currently Not Logged In, Please Login To See A Complete List Of Commands Available To You.", true, MSG_NOTICE);
+				}
+			}
+			else
+			{
+				QueryResult *result = WorldDatabase.PQuery("SELECT `Description`, `gmlevel` FROM `IRC_Commands` WHERE `Command` = '%s'", _PARAMS[0].c_str());			
+				if(result)
+				{
+					Field *fields = result->Fetch();
+					if(fields[1].GetUInt32() > 0)
+					{	
+						Send_IRCA(CD->USER, " You Do Not Have Access To That Command, So No Help Is Available.", true, MSG_NOTICE);
+						return;
+					}
+					std::string cmdhlp = fields[0].GetCppString();
+					delete result;
+					Send_IRCA(CD->USER, cmdhlp, true, MSG_NOTICE);
+				}
+				else
+				Send_IRCA(CD->USER, " 4[ERROR] : No Such Command Exists, Please Check The Spelling And Try Again.", true, MSG_NOTICE);
+			}
+		}
+	}
+	else
+	Send_IRC(ChanOrPM(CD), " 4[ERROR] : Database Error! Please Make Sure You Used IRC_Commands.sql, You Must Have A Table In Your World Database (IRC_Commands)!", true);
+}
+void IRCCmd::Inchan_Server(_CDATA *CD)
+{
+	std::string* _PARAMS = getArray(CD->PARAMS, 1);
+	if(_PARAMS[0] == "")
+	{
+		Send_IRCA(CD->USER, " 4[ERROR] : Syntax Error! ( "+sIRC._cmd_prefx+"inchan <ChannelName> )", true, MSG_NOTICE);
+		return;
+	}
+	QueryResult *result = WorldDatabase.PQuery("SELECT * FROM `IRC_Inchan` WHERE `channel` = '%s' ORDER BY `name`", _PARAMS[0].c_str());
+	if(result)
+	{
+	    Field *fields = result->Fetch();
+		std::string output = "Players In The [ "+fields[2].GetCppString()+" ] Channel: ";
+		for (uint64 i=0; i < result->GetRowCount(); i++)
+		{
+			output += fields[1].GetCppString() + ", ";
+			result->NextRow();
+		}
+		delete result;
+		Send_IRC(ChanOrPM(CD), output, true);
+	}
+	else
+	Send_IRCA(CD->USER, "No Players Are Currently In [ "+_PARAMS[0]+" ] Channel!", true, MSG_NOTICE);
+}
+void IRCCmd::Info_Server(_CDATA *CD)
+{
+        std::string* _PARAMS = getArray(CD->PARAMS, 1);
+        char clientsNum [50];
+        sprintf(clientsNum, "%u", sWorld.GetActiveSessionCount());
+        char maxClientsNum [50];
+        sprintf(maxClientsNum, "%u", sWorld.GetMaxSessionCount());
+        std::string str = secsToTimeString(sWorld.GetUptime());
+        Send_IRC(ChanOrPM(CD), " Number Of Players Online: " + (std::string)clientsNum + ". (Max Since Last Restart: " + (std::string)maxClientsNum + ")" + " Uptime: " + str, true);
+}
+void IRCCmd::Item_Player(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, 3);
+    std::string player  = _PARAMS[0];
+    normalizePlayerName(player);
+    uint64 guid = objmgr.GetPlayerGUIDByName(player.c_str());
+    Player *chr = objmgr.GetPlayer(guid);
+	if(_PARAMS[1] == "add")
+	{
+	    std::string s_param  = _PARAMS[2];
+		char *args = (char*)s_param.c_str();
+		uint32 itemId = 0;
+	    if(args[0]=='[')
+	    {
+	        char* citemName = citemName = strtok((char*)args, "]");
+	        if(citemName && citemName[0])
+	        {
+	            std::string itemName = citemName+1;
+	            WorldDatabase.escape_string(itemName);
+	            QueryResult *result = WorldDatabase.PQuery("SELECT entry FROM item_template WHERE name = '%s'", itemName.c_str());
+	            if (!result)
+	            {
+	                Send_IRCA(CD->USER, " 4[ERROR] : Item Not Found!", true, MSG_NOTICE);
+	                return;
+	            }
+	            itemId = result->Fetch()->GetUInt16();
+	            delete result;
+	        }
+	        else
+	        {
+	            Send_IRCA(CD->USER, " 4[ERROR] : Syntax Error! ( "+sIRC._cmd_prefx+"item <Player> <add> [Exact Item Name] <Amount> )", true, MSG_NOTICE);
+	            return;
+		    }
+	    }
+	    else
+	    {
+	        std::string itemName = s_param;
+	        WorldDatabase.escape_string(itemName);
+	        QueryResult *result = WorldDatabase.PQuery("SELECT entry FROM item_template WHERE name = '%s'", itemName.c_str());
+	        if (result)
+	        {
+	            itemId = result->Fetch()->GetUInt16();
+	        }
+	        delete result;
+	
+	        char* cId = strtok(args, " ");
+	        if(!cId)
+	        {
+	            Send_IRCA(CD->USER, " 4[ERROR] : Syntax Error! ( "+sIRC._cmd_prefx+"item <Player> <add> <ItemID> <Amount> )", true, MSG_NOTICE);
+	            return;
+	        }
+	        itemId = atol(cId);
+		}
+	    char* ccount = strtok(NULL, " ");
+	    int32 count = 1;
+	    if (ccount) { count = atol(ccount); }
+	    if (count < 1) { count = 1; }
+	    Player* plTarget = chr;
+	    if ( !plTarget )
+	    {
+			Send_IRCA(CD->USER, " 4[ERROR] : "+_PARAMS[0]+" Is Not Online!", true, MSG_NOTICE);
+			return;
+		}
+		sLog.outDetail(LANG_ADDITEM, itemId, count);
+		ItemPrototype const *pProto = objmgr.GetItemPrototype(itemId);
+		if(!pProto)
+	    {
+	        Send_IRCA(CD->USER, " 4[ERROR] : Invalid Item!", true, MSG_NOTICE);
+	        return;
+	    }
+	    uint32 countForStore = count;
+	    // item used in local operations and in add item notifier
+	    Item* item = NULL;
+	    // if possible create full stacks for better performance
+	    while(countForStore >= pProto->Stackable)
+	    {
+			uint16 dest;
+	        uint8 msg = plTarget->CanStoreNewItem( NULL_BAG, NULL_SLOT, dest, itemId, pProto->Stackable, false );
+	        if( msg == EQUIP_ERR_OK )
+	        {
+	            item = plTarget->StoreNewItem( dest, itemId, pProto->Stackable, true, Item::GenerateItemRandomPropertyId(itemId));
+	            countForStore-= pProto->Stackable;
+	        }
+	        else
+	            break;
+	    }
+	    // create remaining items
+	    if(countForStore > 0 && countForStore < pProto->Stackable)
+	    {
+	        uint16 dest;
+	        uint8 msg = plTarget->CanStoreNewItem( NULL_BAG, NULL_SLOT, dest, itemId, countForStore, false );
+	        // if can add all countForStore items
+	        if( msg == EQUIP_ERR_OK )
+	        {
+	            item = plTarget->StoreNewItem( dest, itemId, countForStore, true, Item::GenerateItemRandomPropertyId(itemId));
+	            countForStore = 0;
+	        }
+		}
+	    // ok search place for add only part from countForStore items in not full stacks
+	    while(countForStore > 0)
+	    {
+	        // find not full stack (last possable place for times after prev. checks)
+	        uint16 dest;
+	        uint8 msg = plTarget->CanStoreNewItem( NULL_BAG, NULL_SLOT, dest, itemId, 1, false );
+	        if( msg == EQUIP_ERR_OK )                           // found
+	        {
+	            // we can fill this stack to max stack size
+	            Item* itemStack = plTarget->GetItemByPos(dest);
+	            if(itemStack)
+	            {
+	                uint32 countForStack = pProto->Stackable - itemStack->GetCount();
+	                // recheck with real item amount
+	                uint8 msg = plTarget->CanStoreNewItem( itemStack->GetBagSlot(), itemStack->GetSlot(), dest, itemId, countForStack, false );
+	                if( msg == EQUIP_ERR_OK )
+	                {
+	                    item = plTarget->StoreNewItem( dest, itemId, countForStack, true, Item::GenerateItemRandomPropertyId(itemId));
+	                    countForStore-= countForStack;
+	                }
+	                else
+	                    break;                                  // not possible with correct work
+	            }
+	            else
+	                break;                                      // not possible with correct work
+	        }
+	        else
+	            break;
+	    }
+	    if(uint32(count) > countForStore && item)
+	    {
+	        plTarget->SendNewItem(item,count - countForStore,true,false);
+	        QueryResult *result = WorldDatabase.PQuery("SELECT name FROM item_template WHERE entry = %d", itemId);
+			char* dbitemname = NULL;
+			if (result)
+			{
+		        dbitemname = (char*)result->Fetch()->GetString();
+	        }
+		    std::string iinfo = " 13[" +player+ "] : Has Been Given Item "+dbitemname+". From: "+CD->USER.c_str()+".";
+	        Send_IRC(ChanOrPM(CD), iinfo, true);
+	        delete result;
+		}
+		if(countForStore > 0)
+		{
+			char s_countForStore[255];
+			sprintf(s_countForStore,"%d",countForStore);
+		    std::string ierror = " 13["+player+"] : Could Not Create All Items! " +s_countForStore+ " Item(s) Were Not Created!";
+	        Send_IRC(ChanOrPM(CD), ierror, true);
+	    }
+	}
+}
+void IRCCmd::Jail_Player(_CDATA *CD)
+{
+	if(ValidParams(CD->PARAMS, 1))
+	{
+		std::string* _PARAMS = getArray(CD->PARAMS, 2);
+		if (Player* plr = GetPlayer(_PARAMS[0]))
+		{
+			uint64 guid = objmgr.GetPlayerGUIDByName(_PARAMS[0]);
+			std::string sReason = "";
+			if(_PARAMS[1] == "release") 
+			{
+				 float rmapid, rposx, rposy, rposz, rposo = 0;
+				 CharacterDatabase.escape_string(_PARAMS[0]);  
+		         QueryResult *result = CharacterDatabase.PQuery( "SELECT `map`, `position_x`, `position_y`, `position_z` FROM `character_homebind` WHERE `guid` = '" I64FMTD "'", (uint64)guid );
+					if(result) 
+					{
+						Field *fields = result->Fetch();
+						rmapid = fields[0].GetUInt16();
+						rposx = fields[1].GetFloat();
+						rposy = fields[2].GetFloat();
+						rposz = fields[3].GetFloat();
+						delete result; 
+						plr->SetMovement(MOVE_UNROOT);
+						plr->TeleportTo(rmapid, rposx, rposy, rposz, rposo);
+						plr->RemoveAurasDueToSpell(42201);
+						plr->RemoveAurasDueToSpell(23775);
+						plr->RemoveAurasDueToSpell(9454);
+						Send_Player(plr, MakeMsg("You Have Been Released By: %s.", CD->USER.c_str()));
+						sReason = " 13["+_PARAMS[0]+"] : Has Been Released By: "+CD->USER+".";
+						Send_IRC(ChanOrPM(CD), sReason, true);
+					}
+			}			
+			else
+			{
+				if(_PARAMS[1] == "")
+					_PARAMS[1] = "No Reason Given.";
+				plr->TeleportTo(13, 13, 13, 13, 0, true, true);
+				plr->SetMovement(MOVE_ROOT);
+				plr->CastSpell(plr, 42201, true);
+				plr->CastSpell(plr, 23775, true);
+				plr->CastSpell(plr, 9454, true);
+				Send_Player(plr, MakeMsg("You Have Been Jailed By: %s. Reason: %s.", CD->USER.c_str(), _PARAMS[1].c_str()));
+				sReason = " 13["+_PARAMS[0]+"] : Has Been Jailed By: "+CD->USER+". Reason: "+_PARAMS[1]+".";
+				Send_IRC(ChanOrPM(CD), sReason, true);
+			}
+		}
+		else
+		Send_IRCA(CD->USER, " 4[ERROR] : "+_PARAMS[0]+" Is Not Online!", true, MSG_NOTICE);
+	}
+}
+void IRCCmd::Kick_Player(_CDATA *CD)
+{
+	std::string* _PARAMS = getArray(CD->PARAMS, CD->PCOUNT);
+	if(_PARAMS[1] == "")
+		_PARAMS[1] = "No Reason Given.";
+	if (Player* plr = GetPlayer(_PARAMS[0]))
+	{
+		plr->GetSession()->KickPlayer();
+		Send_IRC(ChanOrPM(CD), " 13["+_PARAMS[0]+"] : Has Been Kicked By: "+CD->USER+". Reason: "+_PARAMS[1]+".", true);
+	}
+	else
+		Send_IRCA(CD->USER, " 4[ERROR] : "+_PARAMS[0]+" Is Not Online!", true, MSG_NOTICE);
+}
+void IRCCmd::Kill_Player(_CDATA *CD)
+{
+	std::string* _PARAMS = getArray(CD->PARAMS, CD->PCOUNT);
+	if (Player* plr = GetPlayer(_PARAMS[0]))
+	{
+		if(plr->isAlive())
+		{
+			plr->DealDamage(plr, plr->GetHealth(), NULL, DIRECT_DAMAGE, SPELL_SCHOOL_NORMAL, NULL, 0, false);
+			plr->SaveToDB();
+        		if(_PARAMS[1] == "")
+				_PARAMS[1] = "No Reason Given.";
+
+			Send_IRC(ChanOrPM(CD), MakeMsg(" 13[%s] : Has Been Killed By: %s.", _PARAMS[0].c_str(), CD->USER.c_str()) +  +  + " Reason: "+_PARAMS[1]+".", true);
+			Send_Player(plr, MakeMsg("You Have Been Killed By: %s. Reason: %s.", CD->USER.c_str(), _PARAMS[1].c_str()));
+		}
+		else
+		Send_IRCA(CD->USER, " 4[ERROR] : "+_PARAMS[0]+" Is Already Dead!", true, MSG_NOTICE);
+	}
+	else
+	Send_IRCA(CD->USER, " 4[ERROR] : "+_PARAMS[0]+" Is Not Online!", true, MSG_NOTICE);
+}
+void IRCCmd::Level_Player(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, CD->PCOUNT);
+    std::string player  = _PARAMS[0];
+    normalizePlayerName(player);
+    uint64 guid = objmgr.GetPlayerGUIDByName(player.c_str());
+    std::string s_newlevel  = _PARAMS[1];
+    uint8 i_newlvl = atoi(s_newlevel.c_str());
+    if(!guid)
+    {
+        Send_IRCA(CD->USER, " 4[ERROR] : Player Not Found!", true, MSG_NOTICE);
+        return;
+    } else if ( i_newlvl < 1 || i_newlvl > sWorld.getConfig(CONFIG_MAX_PLAYER_LEVEL) )
+    {
+        Send_IRCA(CD->USER, MakeMsg(" 4[ERROR] : Level Must Be Between 1 And %i!",sConfig.GetIntDefault("MaxPlayerLevel", 70)), true, MSG_NOTICE);
+        return;
+    } else
+    {
+        Player *chr = objmgr.GetPlayer(guid);
+        int32 i_oldlvl = chr ? chr->getLevel() : Player::GetUInt32ValueFromDB(UNIT_FIELD_LEVEL,guid);
+        if(chr)
+        {
+            chr->GiveLevel(i_newlvl);
+            chr->InitTalentForLevel();
+            chr->SetUInt32Value(PLAYER_XP,0);
+            WorldPacket data;
+			ChatHandler CH(chr->GetSession());
+            if(i_oldlvl == i_newlvl)
+				CH.FillSystemMessageData(&data, LANG_YOURS_LEVEL_PROGRESS_RESET);
+            else
+            if(i_oldlvl < i_newlvl)
+                CH.FillSystemMessageData(&data, fmtstring(LANG_YOURS_LEVEL_UP,i_newlvl-i_oldlvl));
+            else
+            if(i_oldlvl > i_newlvl)
+                CH.FillSystemMessageData(&data, fmtstring(LANG_YOURS_LEVEL_DOWN,i_newlvl-i_oldlvl));
+             chr->GetSession()->SendPacket( &data );
+        }
+        else
+        {
+            Tokens values;
+            Player::LoadValuesArrayFromDB(values,guid);
+            Player::SetUInt32ValueInArray(values,UNIT_FIELD_LEVEL,i_newlvl);
+            Player::SetUInt32ValueInArray(values,PLAYER_XP,0);
+            Player::SaveValuesArrayInDB(values,guid);
+        }
+    }
+	Send_IRC(ChanOrPM(CD), " 13["+player+"] : Has Been Leveled To "+s_newlevel+". By: "+CD->USER+".", true);
+}
+void IRCCmd::Money_Player(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, 2);
+    std::string player  = _PARAMS[0];
+    normalizePlayerName(player);
+    uint64 guid = objmgr.GetPlayerGUIDByName(player.c_str());
+    Player *chr = objmgr.GetPlayer(guid);
+
+    std::string s_money  = _PARAMS[1];
+    int32 money = atoi(s_money.c_str());
+    unsigned int gold = money / 10000;
+    unsigned int silv = (money % 10000) / 100;
+    unsigned int cop = (money % 10000) % 100;
+    char tempgold [100];
+    sprintf(tempgold, "\x2\x3\x30\x37%ug \x3\x31\x34%us \x3\x30\x35%uc\xF", gold, silv, cop);
+    if(!guid)
+    {
+        Send_IRCA(CD->USER, " 4[ERROR] : Player Not Found!", true, MSG_NOTICE);
+    } 
+	else
+	{
+		Player *chr = objmgr.GetPlayer(guid);
+        CharacterDatabase.escape_string(player);  
+		std::string sqlquery = "SELECT SUBSTRING_INDEX(SUBSTRING_INDEX(data, ' ' , 1325), ' ' , -1) AS `gold` FROM `character` WHERE `name` = '"+player+"';";
+		QueryResult *result = CharacterDatabase.Query(sqlquery.c_str());
+	  if(result) 
+	  {
+		Field *fields = result->Fetch();
+		uint32 moneyuser = fields[0].GetInt32();
+		delete result;     
+		int32 addmoney = money;
+        //uint32 moneyuser = chr->GetMoney();
+        int32 newmoney = moneyuser + addmoney;
+        char s_newmoney[255];
+        sprintf(s_newmoney,"%d",newmoney);
+		if(addmoney < 0)
+        {
+            sLog.outDetail(LANG_CURRENT_MONEY, moneyuser, addmoney, newmoney);
+            if(newmoney <= 0 )
+            {
+				Send_IRC(ChanOrPM(CD), " 13["+player+"] : Has Had All Money Taken By: "+CD->USER.c_str()+".", true);
+                if(chr) 
+				{
+					chr->SetMoney(0);
+					Send_Player(chr, MakeMsg("You Have Been Liquidated By: %s. Total Money Is Now 0.", CD->USER.c_str()));
+				}
+				else
+				CharacterDatabase.PExecute("UPDATE `character` SET data=concat(substring_index(data,' ',1325-1),' ','%u',' ', right(data,length(data)-length(substring_index(data,' ',1325))-1) ) where guid='%u'",newmoney, guid );
+            }
+            else
+            {
+				Send_IRC(ChanOrPM(CD), " 13["+player+"] : Has Had ("+tempgold+"13) Taken From Them By: "+CD->USER.c_str()+".", true);
+                if(chr) 
+				{
+					chr->SetMoney( newmoney );
+					Send_Player(chr, MakeMsg("You Have Had %s Copper Taken From You By: %s.", _PARAMS[1].c_str(), CD->USER.c_str()));
+				}
+				else
+				CharacterDatabase.PExecute("UPDATE `character` SET data=concat(substring_index(data,' ',1325-1),' ','%u',' ', right(data,length(data)-length(substring_index(data,' ',1325))-1) ) where guid='%u'",newmoney, guid );
+            }
+        }
+        else
+        {
+            Send_IRC(ChanOrPM(CD), " 13["+player+"] : Has Been Given ("+tempgold+"13) From: "+CD->USER.c_str()+".", true);
+            if(chr) 
+				{
+					chr->ModifyMoney( addmoney );
+					Send_Player(chr, MakeMsg("You Have Been Given %s Copper. From: %s.", _PARAMS[1].c_str(), CD->USER.c_str()));
+				}				
+			else
+			CharacterDatabase.PExecute("UPDATE `character` SET data=concat(substring_index(data,' ',1325-1),' ','%u',' ', right(data,length(data)-length(substring_index(data,' ',1325))-1) ) where guid='%u'",newmoney, guid );
+		}
+	   }
+	  else
+	  Send_IRCA(CD->USER, " 4[ERROR] : No Result!", true, MSG_NOTICE);
+	}
+}
+void IRCCmd::Mute_Player(_CDATA *CD)
+{
+	std::string* _PARAMS = getArray(CD->PARAMS, 3);
+	normalizePlayerName(_PARAMS[0]);
+	uint64 guid = objmgr.GetPlayerGUIDByName(_PARAMS[0]);
+	if(guid)
+	{
+		if(_PARAMS[1] == "release")
+		{
+            Player* plr = objmgr.GetPlayer(guid);
+			uint32 account_id = 0;
+			account_id = objmgr.GetPlayerAccountIdByGUID(guid);
+			// Send_IRC(ChanOrPM(CD), " 13 [ T E S T ]" ,true);
+			loginDatabase.PExecute("UPDATE `account` SET `mutetime` = '0' WHERE `id` = '%u'", account_id );
+			Send_IRC(ChanOrPM(CD), " 13["+_PARAMS[0]+"] : Has Been UnMuted By: "+CD->USER+"." ,true);
+			if(plr) Send_Player(plr, MakeMsg("You Have Been UnMuted By: %s.", CD->USER.c_str()));
+		}
+		else // (Player* plr = GetPlayer(_PARAMS[0]))
+		{
+			if(_PARAMS[2] == "")
+				_PARAMS[2] = "No Reason Given";			
+			Player* plr = objmgr.GetPlayer(guid);
+			time_t mutetime = time(NULL) + atoi(_PARAMS[1].c_str())*60;
+            uint32 account_id = 0;
+			account_id = objmgr.GetPlayerAccountIdByGUID(guid);
+            if(plr) plr->GetSession()->m_muteTime = mutetime;
+            loginDatabase.PExecute("UPDATE `account` SET `mutetime` = " I64FMTD " WHERE `id` = '%u'",uint64(mutetime), account_id );
+			Send_IRC(ChanOrPM(CD), " 13["+_PARAMS[0]+"] : Has Been Muted By: "+CD->USER+". For: "+_PARAMS[1]+" Minutes. Reason: "+_PARAMS[2] ,true);
+			if(plr) Send_Player(plr, MakeMsg("You Have Been Muted By: %s. For: %s Minutes. Reason: %s", CD->USER.c_str(), _PARAMS[1].c_str(), _PARAMS[2].c_str()));
+		}
+	}
+	else
+	Send_IRCA(CD->USER, " 4[ERROR] : Player Does Not Exist!", true, MSG_NOTICE);
+}
+void IRCCmd::Online_Players(_CDATA *CD)
+{
+	int OnlineCount = 0;
+	std::string IRCOut = "";
+	HashMapHolder<Player>::MapType& m = ObjectAccessor::Instance().GetPlayers();
+    for(HashMapHolder<Player>::MapType::iterator itr = m.begin(); itr != m.end(); ++itr)
+    {
+        if (itr->second && itr->second->GetSession()->GetPlayer() && itr->second->GetSession()->GetPlayer()->IsInWorld())
+		{
+		OnlineCount++;
+		Player *plr = itr->second->GetSession()->GetPlayer();
+		std::string ChatTag = " ";
+		if(plr->isAFK())
+			ChatTag.append("7<AFK>");
+		if(plr->isDND())
+			ChatTag.append("7<DND>");
+		if(itr->second->GetSession()->GetSecurity() > sConfig.GetIntDefault("OnlineGM", 2))
+			ChatTag.append("9<GM>");
+		if(itr->second->GetSession()->GetSecurity() > 0)
+			ChatTag.append("");
+                switch (plr->GetTeam())
+                {
+                   case 67:ChatTag.append("4");break; //horde
+                   case 469:ChatTag.append("12");break; //alliance
+                }
+		IRCOut.append(MakeMsg("%s%s(%d)", ChatTag.c_str(), plr->GetName(), plr->getLevel()));
+        }
+    }
+	Send_IRC(ChanOrPM(CD), MakeMsg("Players Online(%d): %s", OnlineCount, IRCOut.c_str()), true);
+}
+void IRCCmd::Player_Info(_CDATA *CD)
+{
+    std::string* _PARAMS = getArray(CD->PARAMS, 1);
+    std::string pname = _PARAMS[0];
+    uint64 guid = objmgr.GetPlayerGUIDByName(pname);
+    CharacterDatabase.escape_string(pname);  
+	std::string sqlquery = "SELECT `guid`, `account`, `name`, `race`, `class`, `online`, SUBSTRING_INDEX(SUBSTRING_INDEX(`data`, ' ' , 35), ' ' , -1) AS `level`, SUBSTRING_INDEX(SUBSTRING_INDEX(`data`, ' ' , 230), ' ' , -1) AS `guildid`, SUBSTRING_INDEX(SUBSTRING_INDEX(`data`, ' ' , 231), ' ' , -1) AS `guildrank`, SUBSTRING_INDEX(SUBSTRING_INDEX(`data`, ' ' , 857), ' ' , -1) AS `xp`, SUBSTRING_INDEX(SUBSTRING_INDEX(`data`, ' ' , 858), ' ' , -1) AS `maxxp`, SUBSTRING_INDEX(SUBSTRING_INDEX(data, ' ' , 1325), ' ' , -1) AS `gold`, SUBSTRING_INDEX(SUBSTRING_INDEX(`data`, ' ' , 1376), ' ' , -1) AS `hk` FROM `character` WHERE `name` LIKE '" + pname + "';";
+    QueryResult *result = CharacterDatabase.Query(sqlquery.c_str());
+        Player *chr = objmgr.GetPlayer(guid);
+        if(result) {
+        Field *fields = result->Fetch();
+        std::string pguid = fields[0].GetCppString();
+        std::string pacct = fields[1].GetCppString();
+        pname = fields[2].GetCppString();
+        uint32 praceid = fields[3].GetUInt32();
+        uint32 pclassid = fields[4].GetUInt32();
+        std::string ponline = (fields[5].GetInt32() == 1 ? "\x3\x30\x33Online" : "\x3\x30\x34Offline\xF");
+        std::string plevel = fields[6].GetCppString();
+        uint32 pguildid = fields[7].GetUInt32();
+        uint32 pguildrank = fields[8].GetUInt32();
+        std::string pxp = fields[9].GetCppString();
+        std::string pmaxxp = fields[10].GetCppString();
+        unsigned int money = fields[11].GetInt32();
+        std::string hk = fields[12].GetCppString();
+        delete result;
+	std::string sqlquery = "SELECT `gmlevel` FROM `account` WHERE `id` = '" + pacct + "';";
+    QueryResult *result = loginDatabase.Query(sqlquery.c_str());  
+		Field *fields2 = result->Fetch();
+        std::string pgmlvl = fields2[0].GetCppString();
+		delete result;
+		std::string guildinfo = "";
+        if (pguildid != 0)
+        {
+            Guild* guild = objmgr.GetGuildById(pguildid);
+            if (guild)
+            {
+                guildinfo = " " + guild->GetRankName(pguildrank) + " Of " + guild->GetName();
+            }
+        }
+		else guildinfo = " None";
+        ChrRacesEntry const* prace = sChrRacesStore.LookupEntry(praceid);
+        ChrClassesEntry const* pclass = sChrClassesStore.LookupEntry(pclassid);
+
+		if (atoi(plevel.c_str()) < sWorld.getConfig(CONFIG_MAX_PLAYER_LEVEL))
+            plevel += " (" + pxp + "/" + pmaxxp + ")";
+        unsigned int gold = money / 10000;
+        unsigned int silv = (money % 10000) / 100;
+        unsigned int cop = (money % 10000) % 100;
+        char tempgold [100];
+        sprintf(tempgold, "\x2\x3\x30\x37%ug \x3\x31\x34%us \x3\x30\x35%uc\xF", gold, silv, cop);
+        if (ponline == "\x3\x30\x33Online")
+        {
+            Player * plr = ObjectAccessor::Instance().FindPlayerByName(pname.c_str());
+            if (plr)
+            {
+                AreaTableEntry const* area = GetAreaEntryByAreaID(plr->GetAreaId());
+                ponline += " in " + (std::string) area->area_name[sWorld.GetDBClang()];
+                if (area->zone != 0)
+                {
+                    AreaTableEntry const* zone = GetAreaEntryByAreaID(area->zone);
+                    ponline += " (" + (std::string)zone->area_name[sWorld.GetDBClang()] + ")";
+                }
+            }
+        }
+		std::string pinfo  = "\x2 About Player:\x3\x31\x30 " +pname+ "\xF |\x2 GM Level:\x3\x31\x30 " +pgmlvl+ "\xF |\x2 AcctID:\x3\x31\x30 " +pacct+ "\xF |\x2 CharID:\x3\x31\x30 " +pguid+ " \xF |\x2 Guild Info:\x2\x3\x31\x30" +guildinfo;
+        std::string pinfo2 = "\x2 Race:\x2\x3\x31\x30 " + (std::string)prace->name[sWorld.GetDBClang()] + "\xF |\x2 Class:\x2\x3\x31\x30 " + (std::string)pclass->name[sWorld.GetDBClang()] + "\xF |\x2 Level:\x2\x3\x31\x30 " + plevel + "\xF |\x2 Money:\x2 " + tempgold + "\xF |\x2 Status:\x2 " + ponline;
+//        pinfo3 = " :" + " \x2Honor Kills:\x2\x3\x31\x30 " + hk;
+        Send_IRC(ChanOrPM(CD),pinfo ,true);
+        Send_IRC(ChanOrPM(CD),pinfo2 ,true);
+//        Send_IRC(ChanOrPM(CD),pinfo3 ,true);
+    }
+    else
+        Send_IRCA(CD->USER, " 4[ERROR] : Unknown Player: " + pname ,true, MSG_NOTICE);
+}
+void IRCCmd::PM_Player(_CDATA *CD)
+{
+	std::string* _PARAMS = getArray(CD->PARAMS, 2);
+	if (Player* plr = GetPlayer(_PARAMS[0]))
+	{
+       if(plr->isAcceptWhispers())
+       {
+		   std::string sMsg = MakeMsg("|cffFE87FD[<IRC>%s] Whispers: %s|r", CD->USER.c_str(), _PARAMS[1].c_str());
+		   WorldPacket data(SMSG_MESSAGECHAT, 200);
+		   data << (uint8)CHAT_MSG_SYSTEM;
+		   data << (uint32)LANG_UNIVERSAL;
+		   data << (uint64)plr->GetGUID();
+		   data << (uint32)0;
+		   data << (uint64)plr->GetGUID();
+		   data << (uint32)(sMsg.length()+1);
+		   data << sMsg;
+		   data << (uint8)0;
+		   plr->GetSession()->SendPacket(&data);
+		   plr->PlaySound(3081, true);
+		   Send_IRC(ChanOrPM(CD), " 13To ["+_PARAMS[0]+"] : "+_PARAMS[1]+".",true);
+	  }
+	  else
+	  Send_IRCA(CD->USER, " 4[ERROR] : Is Not Accepting Private Messages!", true, MSG_NOTICE);
+	}
+	else
+	Send_IRCA(CD->USER, " 4[ERROR] : Player not online!", true, MSG_NOTICE);
+}
+void IRCCmd::Revive_Player(_CDATA *CD)
+{
+	std::string* _PARAMS = getArray(CD->PARAMS, CD->PCOUNT);
+	if (Player* plr = GetPlayer(_PARAMS[0]))
+	{
+		if(plr->isDead())
+		{
+	        plr->ResurrectPlayer(0.5f);
+	        plr->SpawnCorpseBones();
+                plr->SaveToDB();
+				sIRC.Send_IRC_Channel(ChanOrPM(CD), " 13["+_PARAMS[0]+"] : Has Been Revived By: " + CD->USER, true);
+			Send_Player(plr, MakeMsg("You Have Been Revived By: %s.", CD->USER.c_str()));
+		}
+		else
+		Send_IRCA(CD->USER, " 4[ERROR] : "+_PARAMS[0]+" Is Not Dead!", true, MSG_NOTICE);
+	}
+	else
+	Send_IRCA(CD->USER, " 4[ERROR] : "+_PARAMS[0]+" Is Not Online!", true, MSG_NOTICE);
+}
+void IRCCmd::Saveall_Player(_CDATA *CD)
+{
+	ObjectAccessor::Instance().SaveAllPlayers();
+	Send_IRC(ChanOrPM(CD), " 13["+CD->USER+"] : Has Saved All Players!",true);
+}
+void IRCCmd::Spell_Player(_CDATA *CD)
+{
+	std::string* _PARAMS = getArray(CD->PARAMS, 3);
+	uint32 spell         = atoi(_PARAMS[2].c_str());
+    SpellEntry const *spellInfo = sSpellStore.LookupEntry(spell);
+    if (Player* plr = GetPlayer(_PARAMS[0]))
+    {
+   	  if(spellInfo)
+	  {
+        std::string name = spellInfo->SpellName[sWorld.GetDBClang()];
+        if(_PARAMS[1] == "cast")
+        {
+			plr->CastSpell(plr, spell, true);
+			Send_IRC(ChanOrPM(CD), " 13["+_PARAMS[0]+"] : Has Had Spell "+name+" Casted On Them.",true);
+        }
+        if(_PARAMS[1] == "learn")
+        {
+			plr->learnSpell(spell);
+			Send_IRC(ChanOrPM(CD), " 13["+_PARAMS[0]+"] : Has Learned Spell "+name+".",true);
+        }
+        if(_PARAMS[1] == "unlearn")
+        {
+			plr->removeSpell(spell);
+			Send_IRC(ChanOrPM(CD), " 13["+_PARAMS[0]+"] : Has Unlearned Spell "+name+".",true);
+        }
+	  }
+	  else
+	  Send_IRCA(CD->USER, " 4[ERROR] : Incorrect Spell ID!", true, MSG_NOTICE);
+    }
+    else
+    Send_IRCA(CD->USER, " 4[ERROR] : Player Not Online!", true, MSG_NOTICE);
+}
+void IRCCmd::Sysmsg_Server(_CDATA *CD)
+{
+        std::string* _PARAMS = getArray(CD->PARAMS, CD->PCOUNT);
+        if(_PARAMS[0] == "a")
+        {
+          std::string str = LANG_SYSTEMMESSAGE + _PARAMS[1];
+          std::string ancmsg = MakeMsg("04,08*[!]*SysMsg*[!]* %s 04,08*[!]*SysMsg*[!]*",_PARAMS[1].c_str());
+          sWorld.SendWorldText(str.c_str(), NULL);
+          Send_IRC(ChanOrPM(CD), ancmsg, true);
+        }
+        else if (_PARAMS[0] == "n")
+        {
+          std::string str = LANG_GLOBAL_NOTIFY + _PARAMS[1];
+          std::string notmsg = MakeMsg("04,08*[!]*SysNotice*[!]* %s 04,08*[!]*SysNotice*[!]*",_PARAMS[1].c_str());
+          WorldPacket data(SMSG_NOTIFICATION, (str.size()+1));
+          data << str;
+          sWorld.SendGlobalMessage(&data);
+          Send_IRC(ChanOrPM(CD), notmsg, true);
+        }
+        else
+        Send_IRCA(CD->USER, " 4[ERROR] : Please Use (a-Announce)(n-Notify) As Second Parameter!", true, MSG_NOTICE);
+}
+void IRCCmd::Tele_Player(_CDATA *CD)
+{
+	bool DoTeleport = false;
+        float pX, pY, pZ, pO = 0;
+        uint32 mapid = 0;
+        std::string rMsg = " 4[ERROR] : Teleport Failed!";
+		std::string wMsg = "Invalid Tele Location";
+	std::string* _PARAMS = getArray(CD->PARAMS, 4);
+	if (Player* plr = GetPlayer(_PARAMS[0]))
+	{
+	  std::string* _PARAMS = getArray(CD->PARAMS, 3);
+	   if(plr->isInFlight())
+           {
+            Send_IRCA(CD->USER, MakeMsg(" 4[ERROR] : %s Is Flying And Cannot Be Teleported!",_PARAMS[0].c_str()), true, MSG_NOTICE);
+            return;
+           }
+       if(_PARAMS[1] == "l")
+	   {	
+           WorldDatabase.escape_string(_PARAMS[2]);
+		   QueryResult *result = WorldDatabase.PQuery("SELECT `position_x`,`position_y`,`position_z`,`orientation`,`map` FROM `game_tele` WHERE `name`='%s';", _PARAMS[2].c_str());
+                if (result)
+                {
+	                Field *fields = result->Fetch();
+                    pX = fields[0].GetFloat();
+                    pY = fields[1].GetFloat();
+                    pZ = fields[2].GetFloat();
+                    pO = fields[3].GetFloat();
+                    mapid = fields[4].GetUInt16();
+                    delete result;
+					rMsg = MakeMsg(" 13[%s] : Teleported To %s! By: %s.",
+					_PARAMS[0].c_str(),
+					_PARAMS[2].c_str(),
+                    CD->USER.c_str());
+					wMsg = MakeMsg("You Have Been Teleported To %s By: %s.",
+					_PARAMS[2].c_str(),
+					CD->USER.c_str());
+				   DoTeleport = true;
+                }
+				else
+     			Send_IRC(ChanOrPM(CD), " 4[ERROR] : Location Not Found!", true);
+		}
+		else if(_PARAMS[1] == "c")
+		{
+			std::string* _PARAMSA = getArray(_PARAMS[2], 4);
+			pX = atof(_PARAMSA[1].c_str());
+			pY = atof(_PARAMSA[2].c_str());
+			pZ = atof(_PARAMSA[3].c_str());
+			mapid = atoi(_PARAMSA[0].c_str());
+			rMsg = MakeMsg(" 13[%s] : Teleported To Map: %s. Position: X(%s) Y(%s) Z(%s)! By: %s.",
+				_PARAMS[0].c_str(),
+				_PARAMSA[0].c_str(),
+				_PARAMSA[1].c_str(),
+				_PARAMSA[2].c_str(),
+				_PARAMSA[3].c_str(),
+                CD->USER.c_str());
+			wMsg = MakeMsg("You Have Been Teleported To Map: %s. Position: X(%s) Y(%s) Z(%s)! By: %s.",
+				_PARAMSA[0].c_str(),
+				_PARAMSA[1].c_str(),
+				_PARAMSA[2].c_str(),
+				_PARAMSA[3].c_str(),
+                CD->USER.c_str());
+			DoTeleport = true;
+		}
+		else if(_PARAMS[1] == "r")
+		{
+			pX = plr->m_recallX;
+			pY = plr->m_recallY;
+			pZ = plr->m_recallZ;
+			pO = plr->m_recallO;
+			mapid = plr->m_recallMap;
+			rMsg = MakeMsg(" 13[%s] : Has Been Recalled To Their Previous Location.",
+				_PARAMS[0].c_str());
+			wMsg = MakeMsg("You Have Been Recalled To Your Previous Location. By: %s",
+				CD->USER.c_str());
+			DoTeleport = true;
+		}
+		else if(_PARAMS[1] == "to")
+		{
+			Player* plr2 = GetPlayer(_PARAMS[2]);
+			uint64 guid = objmgr.GetPlayerGUIDByName(_PARAMS[2]);
+				if(plr2)
+				{
+					Player::LoadPositionFromDB(mapid,pX,pY,pZ,pO,guid);
+						rMsg = MakeMsg(" 13[%s] : Teleported To Player: [%s] By: %s.",
+							_PARAMS[0].c_str(),
+							_PARAMS[2].c_str(),
+							CD->USER.c_str());
+						wMsg = MakeMsg("You Are Being Teleported To: %s. By: %s.",
+							_PARAMS[2].c_str(),
+							CD->USER.c_str());
+					DoTeleport = true;
+				}
+				else
+				Send_IRC(ChanOrPM(CD), " 4[ERROR] : Second Player Not Found!", true);
+		}
+		if(DoTeleport)
+		{
+			if(MapManager::IsValidMapCoord(mapid, pX ,pY))
+			{
+				plr->SaveRecallPosition();
+				plr->TeleportTo(mapid, pX, pY, pZ, pO);
+				sIRC.Send_IRC_Channel(ChanOrPM(CD), rMsg, true);
+				Send_Player(plr, wMsg);
+			}
+			else
+			Send_IRCA(CD->USER, " 4[ERROR] : Invalid Location!", true, MSG_NOTICE);
+		}
+	}
+	else
+	Send_IRCA(CD->USER, " 4[ERROR] : Player not online!", true, MSG_NOTICE);
+}
+void IRCCmd::Who_Logged(_CDATA *CD)
+{
+	std::string OPS = "";
+	for(int i = 0;i < MAX_CLIENTS;i++)
+	{
+		if(CLIENTS[i].LoggedIn)
+		{
+			OPS.append(MakeMsg(" [GM:%d IRC: %s - WoW: %s] ", CLIENTS[i].GMLevel, CLIENTS[i].Name.c_str() ,CLIENTS[i].UName.c_str()));
+		}
+	}
+	Send_IRC(ChanOrPM(CD), OPS, true);
+}
+
+// OK THIS CODE IS COMPLETLY USESLESS AND HAVE ABSOLUTLY NOTHING TODO WITH IRC ANYMORE HEHE
+// But its pretty funny
+// What this does it create a new thread and execute a little "script"
+// it spawns a npc near the player and roots it it greets the player
+// then casts buff spells stamina, intellect, spirit then leaves
+// the purpose of this all was to learn more about the unit classes and grid
+// i tworks fine with 1 player (so far my own tests) and a few spawns
+// i do not know the stability and functionality with a "loaded" server
+// and multiple buffers in theorty each buffer is on its own thread
+// and should be spawn and talk to the correct player regaredles where
+// they are in the world
+// ** USE THIS AT YOUR OWN RISK
+#define NPC_ENTRY sIRC.ZBUFF_NPC
+#define SPELL_ANIM sIRC.ZBUFF_ANIM
+#define CAST_SPELL_1 sIRC.ZBUFF_SPELL1 // 25389 POWER WORD
+#define CAST_SPELL_2 sIRC.ZBUFF_SPELL2 // 10157 //27126 //ARC INT
+#define CAST_SPELL_3 sIRC.ZBUFF_SPELL3 // 25312// DIVINE SPIRIT
+#ifdef WIN32
+#define Delay(x) Sleep(x)
+#else
+#define Delay(x) sleep(x / 1000)
+#endif
+#ifdef _WIN32
+DWORD	WINAPI Buff_Script(void* ptr)
+#else
+void *Buff_Script( void *ptr )
+#endif
+{
+	if(sIRC._Max_Script_Inst == MAX_SCRIPT_INST)
+		return 0;
+	sIRC._Max_Script_Inst++;
+	std::string pname = (char *)ptr;
+	normalizePlayerName(pname);
+	if (Player* plr = ObjectAccessor::Instance().FindPlayerByName(pname.c_str()))
+	{
+	    Creature* pCreature = new Creature(plr);
+		if (!pCreature->Create(objmgr.GenerateLowGuid(HIGHGUID_UNIT),
+			plr->GetMapId(),
+			plr->GetPositionX()  - 3,
+			plr->GetPositionY() - 3,
+			plr->GetPositionZ() + 5,
+			plr->GetOrientation() - 2.5,
+			NPC_ENTRY,
+			plr->GetTeam())) { delete pCreature; }
+		else
+		{
+			Delay(500);
+			pCreature->SaveToDB();
+			pCreature->LoadFromDB(pCreature->GetGUIDLow(), plr->GetInstanceId());// To call _LoadGoods(); _LoadQuests(); CreateTrainerSpells();
+			plr->SetMovement(MOVE_ROOT);
+			plr->PlaySound(S_ENTERWORLD ,true);
+			MapManager::Instance().GetMap(pCreature->GetMapId(), pCreature)->Add(pCreature);
+			Delay(500);
+			pCreature->Say("Hello I Have Been Sent To Help You.", LANG_UNIVERSAL, plr->GetGUID());
+			Delay(2000);
+			pCreature->CastSpell(plr, sSpellStore.LookupEntry( SPELL_ANIM ), true);
+			Delay(2000);
+			pCreature->CombatStop();
+			if(SpellEntry const *spellInfo = sSpellStore.LookupEntry( CAST_SPELL_1 ))
+			{
+				for(uint32 i = 0;i<3;i++)
+				{
+					uint8 eff = spellInfo->Effect[i];
+					if (eff>=TOTAL_SPELL_EFFECTS)
+						continue;
+					if (eff == SPELL_EFFECT_APPLY_AURA || eff == SPELL_EFFECT_APPLY_AREA_AURA || eff == SPELL_EFFECT_PERSISTENT_AREA_AURA)
+					{
+						Aura *Aur = new Aura(spellInfo, i, NULL, plr);
+						plr->AddAura(Aur);
+					}
+				}
+			}
+			Delay(1000);
+			if(SpellEntry const *spellInfo = sSpellStore.LookupEntry( CAST_SPELL_2 ))
+			{
+				for(uint32 i = 0;i<3;i++)
+				{
+					uint8 eff = spellInfo->Effect[i];
+					if (eff>=TOTAL_SPELL_EFFECTS)
+						continue;
+					if (eff == SPELL_EFFECT_APPLY_AURA || eff == SPELL_EFFECT_APPLY_AREA_AURA || eff == SPELL_EFFECT_PERSISTENT_AREA_AURA)
+					{
+						Aura *Aur = new Aura(spellInfo, i, NULL, plr);
+						plr->AddAura(Aur);
+					}
+				}
+			}
+			Delay(1000);
+			if(SpellEntry const *spellInfo = sSpellStore.LookupEntry( CAST_SPELL_3 ))
+			{
+				for(uint32 i = 0;i<3;i++)
+				{
+					uint8 eff = spellInfo->Effect[i];
+					if (eff>=TOTAL_SPELL_EFFECTS)
+						continue;
+					if (eff == SPELL_EFFECT_APPLY_AURA || eff == SPELL_EFFECT_APPLY_AREA_AURA || eff == SPELL_EFFECT_PERSISTENT_AREA_AURA)
+					{
+						Aura *Aur = new Aura(spellInfo, i, NULL, plr);
+						plr->AddAura(Aur);
+					}
+				}
+			}
+			Delay(2000);
+			pCreature->Say("I Must Bid You Farewell Now.", LANG_UNIVERSAL, plr->GetGUID());
+			Delay(1000);
+			plr->SetMovement(MOVE_UNROOT);
+			plr->PlaySound(S_STEALTH ,true);
+			pCreature->CombatStop();
+			pCreature->DeleteFromDB();
+			pCreature->CleanupsBeforeDelete();
+			ObjectAccessor::Instance().AddObjectToRemoveList(pCreature);
+		}
+	}
+	sIRC._Max_Script_Inst--;
+	return 0;
+}
+void IRCCmd::Zbuff_Player(_CDATA *CD)
+{
+	std::string* _PARAMS = getArray(CD->PARAMS, 1);
+	if (Player* plr = GetPlayer(_PARAMS[0]))
+	{
+               #ifdef _WIN32
+	    	   CreateThread(NULL, 0, Buff_Script, (void*)plr->GetName(), 0, NULL);
+		       #else
+               MThread *newthr = new MThread ();
+               pthread_create(&newthr->tid, NULL, &Buff_Script, (void*)plr->GetName());
+               #endif
+	           sIRC.Send_IRC_Channel(ChanOrPM(CD), MakeMsg(" 13[%s] : Has Been Buffed!",_PARAMS[0].c_str()), true);
+	}
+	else
+	Send_IRCA(CD->USER, " 4[ERROR] : Player Not Online!", true, MSG_NOTICE);
+}
Index: src/game/IRCConf.cpp
===================================================================
--- src/game/IRCConf.cpp	(revision 0)
+++ src/game/IRCConf.cpp	(revision 0)
@@ -0,0 +1,126 @@
+#include "IRCClient.h"
+#include "Config/ConfigEnv.h"
+bool IRCClient::LoadConfig()
+{
+	int ConfCnt = 0;
+	sIRC._chan_count = 0;
+	if(sConfig.GetIntDefault("irc.active", 1) == 1)
+		sIRC.Active = true;
+	else
+		sIRC.Active = false;
+	sIRC._Host = sConfig.GetStringDefault("irc.host", "irc.freenode.net");
+	if(sIRC._Host.size() > 0)
+		ConfCnt++;
+	sIRC._Port = sConfig.GetIntDefault("irc.port", 6667);
+	sIRC._User = sConfig.GetStringDefault("irc.user", "mangchat");
+	sIRC._Pass = sConfig.GetStringDefault("irc.pass", "mangchat");
+	sIRC._Nick = sConfig.GetStringDefault("irc.nick", "mangchat");
+	sIRC._Auth = sConfig.GetIntDefault("irc.auth", 0);
+	sIRC._ICC = sConfig.GetStringDefault("irc.icc", "001");
+	sIRC._defchan = sConfig.GetStringDefault("irc.defchan", "lobby");
+	sIRC._ldefc = sConfig.GetIntDefault("irc.ldef", 0);
+	sIRC._wct = sConfig.GetIntDefault("irc.wct", 30000);
+	sIRC.BOTMASK = sConfig.GetIntDefault("Botmask", 0);
+	for(int i = 1; i < MAX_CONF_CHANNELS;i++)
+	{
+	    std::ostringstream ss;
+	    ss << i;
+		std::string ci = "irc.chan_" + ss.str();
+		std::string t_chan = sConfig.GetStringDefault(ci.c_str(), "");
+		if(t_chan.size() > 0)
+		{
+			sIRC._chan_count++;
+			sIRC._irc_chan[sIRC._chan_count] = t_chan;
+			ci = "wow.chan_" + ss.str();
+			sIRC._wow_chan[sIRC._chan_count] = sConfig.GetStringDefault(ci.c_str(), t_chan.c_str());
+		}
+	}
+    sIRC.JoinMsg = sConfig.GetStringDefault("irc.joinmsg", "Whhaaazzzzaaaa, MangChat 1.0 Baby!!");
+    sIRC.RstMsg  = sConfig.GetStringDefault("irc.rstmsg", "MangChat Is Restarting, I Will Be Right Back!");
+	sIRC.kikmsg = sConfig.GetStringDefault("irc.kickmsg", "Do Not Kick Me Again, Severe Actions Will Be Taken!");
+	// IRC LINES
+	sIRC.ILINES[WOW_IRC] = sConfig.GetStringDefault("chat.wow_irc", "<WoW>[$Name($Level)] $Msg");
+	sIRC.ILINES[IRC_WOW] = sConfig.GetStringDefault("chat.irc_wow", "<IRC>[$Name]: $Msg");
+	sIRC.ILINES[JOIN_WOW] = sConfig.GetStringDefault("chat.join_wow", "12>>04 $Name Joined The Channel!");
+	sIRC.ILINES[JOIN_IRC] = sConfig.GetStringDefault("chat.join_irc", "[$Name]: Has Joined IRC!");
+	sIRC.ILINES[LEAVE_WOW] = sConfig.GetStringDefault("chat.leave_wow", "12<<04 $Name Left The Channel!");
+	sIRC.ILINES[LEAVE_IRC] = sConfig.GetStringDefault("chat.leave_irc", "[$Name]: Has Left IRC!");
+	sIRC.ILINES[CHANGE_NICK] = sConfig.GetStringDefault("chat.change_nick", "<> $Name Is Now Known As $NewName!");
+	// MangChat Options
+	sIRC._MCA = sConfig.GetIntDefault("irc.maxattempt", 10);
+	sIRC._autojoinkick = sConfig.GetIntDefault("irc.autojoin_kick", 1);
+	sIRC._cmd_prefx = sConfig.GetStringDefault("irc.command_prefix", ".");
+    // Misc Options
+    sIRC.BOTMASK   = sConfig.GetIntDefault("BotMask", 0);
+    sIRC.ojGM1 = sConfig.GetStringDefault("irc.gm1", "[Moderator]");
+	sIRC.ojGM2 = sConfig.GetStringDefault("irc.gm2", "[Game Master]");
+	sIRC.ojGM3 = sConfig.GetStringDefault("irc.gm3", "[BugTracker]");
+	sIRC.ojGM4 = sConfig.GetStringDefault("irc.gm4", "[DevTeam Admin]");
+	sIRC.ojGM5 = sConfig.GetStringDefault("irc.gm5", "[Root Admin]");
+	// REQUIRED GM LEVEL}
+	QueryResult *result = WorldDatabase.PQuery("SELECT `Command`, `gmlevel` FROM `IRC_Commands` ORDER BY `Command`");
+	if(result)
+	{
+	    Field *fields = result->Fetch();
+		for (uint64 i=0; i < result->GetRowCount(); i++)
+		{
+			std::string command = fields[0].GetCppString();
+			uint32 gmlvl = fields[1].GetUInt32();
+		    if(command == "fun") sIRC.CFUN = gmlvl;
+			if(command == "item") sIRC.CITEM = gmlvl;
+			if(command == "jail") sIRC.CJAIL = gmlvl;
+			if(command == "kick") sIRC.CKICK = gmlvl;
+			if(command == "kill") sIRC._KILL = gmlvl;
+			if(command == "level") sIRC.CLEVEL = gmlvl;
+			if(command == "money") sIRC.CMONEY = gmlvl;
+			if(command == "mute") sIRC.CMUTE = gmlvl;
+			if(command == "player") sIRC.CPLAYER = gmlvl;
+			if(command == "pm") sIRC.CPM = gmlvl;
+			if(command == "restart") sIRC.CRESTART = gmlvl;
+			if(command == "revive") sIRC.CREVIVE = gmlvl;
+			if(command == "saveall") sIRC.CSAVEALL = gmlvl;
+			if(command == "spell") sIRC.CSPELL = gmlvl;
+			if(command == "sysmsg") sIRC.CSYSMSG = gmlvl;
+			if(command == "tele") sIRC.CTELE = gmlvl;
+			if(command == "who") sIRC.CWHO = gmlvl;
+			if(command == "zbuff") sIRC.CZBUFF = gmlvl;
+			result->NextRow();
+		}
+		delete result;
+	}
+	else
+	{
+		sIRC.CFUN      = 3;
+		sIRC.CITEM     = 3;
+		sIRC.CJAIL     = 3;
+		sIRC.CKICK     = 3;
+		sIRC._KILL     = 3;
+		sIRC.CLEVEL    = 3;
+		sIRC.CMONEY    = 3;
+		sIRC.CMUTE     = 3;
+		sIRC.CPLAYER   = 3;
+		sIRC.CPM       = 3;
+		sIRC.CRESTART  = 3;
+		sIRC.CREVIVE   = 3;
+		sIRC.CSAVEALL  = 3;
+		sIRC.CSPELL    = 3;
+		sIRC.CSYSMSG   = 3;
+		sIRC.CTELE     = 3;
+		sIRC.CWHO      = 3;
+		sIRC.CZBUFF    = 3;
+	}
+	// ZBUFF SCRIPT
+	sIRC.ZBUFF_NPC    = sConfig.GetIntDefault("zbuff.npc", 1000);
+	sIRC.ZBUFF_ANIM   = sConfig.GetIntDefault("zbuff.anim", 1000); 
+	sIRC.ZBUFF_SPELL1 = sConfig.GetIntDefault("zbuff.spell1", 25389);
+	sIRC.ZBUFF_SPELL2 = sConfig.GetIntDefault("zbuff.spell2", 10157);
+	sIRC.ZBUFF_SPELL3 = sConfig.GetIntDefault("zbuff.spell3", 25312);
+	sIRC.HBUFF_SPELL1 = sConfig.GetIntDefault("help.spell1", 31984);
+	sIRC.HBUFF_SPELL2 = sConfig.GetIntDefault("help.spell2", 35354);
+	sIRC.HBUFF_SPELL3 = sConfig.GetIntDefault("help.spell3", 35354);
+	return true;
+}
+std::string IRCClient::GetChatLine(int nItem)
+{
+	return sIRC.ILINES[nItem];
+}
Index: src/game/IRCFunc.h
===================================================================
--- src/game/IRCFunc.h	(revision 0)
+++ src/game/IRCFunc.h	(revision 0)
@@ -0,0 +1,252 @@
+std::string GetUser(std::string szU)
+{
+    int pos = szU.find("!");
+    return szU.substr(0, pos);
+}
+
+// Delink will remove anything considered "non chat" from a string
+// Linked items (items that players can click on to see a description)
+// contain extra characters wich the client filter out, this function
+// makes sure people on irc do not see those characters.
+std::string Delink(std::string msg)
+{
+    std::size_t pos;
+    while ((pos = msg.find("|Hitem")) != std::string::npos)
+    {
+        msg.replace(pos, msg.find("|h") - pos + 2, "\x2");
+        msg.replace(msg.find("|h"), 2, "\x2");
+    }
+    while ((pos = msg.find("|Henchant")) != std::string::npos)
+    {
+        msg.replace(pos, msg.find("|h") - pos + 2, "\x2");
+        msg.replace(msg.find("|h"), 2, "\x2");
+    }
+    return msg;
+}
+
+// This function converts the characters used by the client to identify colour to IRC format.
+std::string WoWcol2IRC(std::string msg)
+{
+   std::size_t pos;
+    char IRCCol[9][4] = { "\xF", "\xF", "\x3\x31\x34", "\x3\x30\x33", "\x3\x31\x32", "\x3\x30\x36", "\x3\x30\x37", "\x3\x30\x34", "\x3\x30\x37"};
+    char WoWCol[9][12] = { "|r", "|cffffffff", "|cff9d9d9d", "|cff1eff00", "|cff0070dd", "|cffa335ee", "|cffff8000", "|cffe6cc80", "cffffd000"};
+    for (int i=0; i<=8; i++)
+    {
+            while ((pos = msg.find(WoWCol[i])) != std::string::npos)
+        {
+            if (i == 0)
+                msg.replace(pos, 2, IRCCol[i]);
+            else
+                msg.replace(pos, 10, IRCCol[i]);
+        }
+    }
+    return msg;
+}
+// This function converts the characters used by IRC to identify colour to a format the client can understand.
+std::string IRCcol2WoW(std::string msg)
+{
+    std::size_t pos;
+    char IRCCol[16][4] = { "\x3\x30", "\x3\x31", "\x3\x32", "\x3\x33", "\x3\x34", "\x3\x35", "\x3\x36", "\x3\x37", "\x3\x38", "\x3\x39", "\x3\x31\x30", "\x3\x31\x31", "\x3\x31\x32", "\x3\x31\x33", "\x3\x31\x34", "\x3\x31\x35"};
+    char IRCCol2[10][4] = { "\x3\x30\x30", "\x3\x30\x31", "\x3\x30\x32", "\x3\x30\x33", "\x3\x30\x34", "\x3\x30\x35", "\x3\x30\x36", "\x3\x30\x37", "\x3\x30\x38", "\x3\x30\x39"};
+    char WoWcol[16][12] = { "|cffffffff", "|cff000000", "|cff00007f", "|cff009300", "|cffff0000", "|cff7f0000", "|cff9c009c", "|cfffc9300", "|cffffff00", "|cff00fc00", "|cff009393", "|cff00ffff", "|cff0000fc", "|cffff00ff", "|cff7f7f7f", "|cffd2d2d2"};
+    for (int i=15; i>=0; i--)
+    {
+        if (i<10)
+        {
+            while ((pos = msg.find(IRCCol2[i])) != std::string::npos)
+            {
+                msg.replace(pos, 3, WoWcol[i]);
+            }
+            while ((pos = msg.find(IRCCol[i])) != std::string::npos)
+            {
+                msg.replace(pos, 2, WoWcol[i]);
+            }
+
+        }
+        else
+        {
+            while ((pos = msg.find(IRCCol[i])) != std::string::npos)
+            {
+                msg.replace(pos, 3, WoWcol[i]);
+            }
+        }
+    }
+
+    while ((pos = msg.find("\x3")) != std::string::npos)
+    {
+        msg.replace(pos, 1, "|r");
+    }
+    while ((pos = msg.find("\xF")) != std::string::npos)
+    {
+        msg.replace(pos, 1, "|r");
+    }
+
+    return msg;
+}
+
+std::string MakeLower(std::string Channel)
+{
+	std::string tmpchan = Channel;
+	std::transform(tmpchan.begin(), tmpchan.end(), tmpchan.begin(), towlower);
+	return tmpchan;
+}
+
+std::string MakeUpper(std::string Channel)
+{
+	std::string tmpchan = Channel;
+	std::transform(tmpchan.begin(), tmpchan.end(), tmpchan.begin(), towupper);
+	return tmpchan;
+}
+
+// This function compares 2 strings
+int nocase_cmp(const string & s1, const string& s2) 
+{
+  string::const_iterator it1=s1.begin();
+  string::const_iterator it2=s2.begin();
+
+  //stop when either string's end has been reached
+  while ( (it1!=s1.end()) && (it2!=s2.end()) ) 
+  { 
+    if(::toupper(*it1) != ::toupper(*it2)) //letters differ?
+     // return -1 to indicate smaller than, 1 otherwise
+      return (::toupper(*it1)  < ::toupper(*it2)) ? -1 : 1; 
+    //proceed to the next character in each string
+    ++it1;
+    ++it2;
+  }
+  size_t size1=s1.size(), size2=s2.size();// cache lengths
+   //return -1,0 or 1 according to strings' lengths
+    if (size1==size2) 
+      return 0;
+    return (size1<size2) ? -1 : 1;
+}
+
+
+std::string MakeMsg(std::string msg, std::string var, std::string val)
+{
+    std::size_t start = msg.find(var);
+    if (start != std::string::npos)
+        msg.replace(start, var.length(), val);
+    return msg;
+}
+
+std::string MakeMsgA(const char *sLine, ... )
+{
+    va_list ap;
+    char tmpoutp[1024];
+	va_start(ap, sLine);
+	vsnprintf(tmpoutp, 1024, sLine, ap );
+    va_end(ap);
+	std::string outp = tmpoutp;
+	return outp;
+}
+
+std::string MakeMsgP(int CLINE, std::string Msg, Player *plr)
+{
+//	std::string ChatTag = "";
+//	switch (plr->GetTeam())
+//	{
+//		case 67:ChatTag.append("4");break; //horde
+//		case 469:ChatTag.append("12");break; //alliance
+//	}
+	std::string sMsg = MakeMsg(sIRC.GetChatLine(CLINE), "$Msg", Msg);
+//	sMsg = ChatTag + MakeMsg(sMsg, "$Name", plr->GetName());
+	if (plr->GetTeam() == 67)
+        sMsg = MakeMsg(sMsg, "$Name", MakeMsgA("4%s", plr->GetName()));
+	else if (plr->GetTeam() == 469)
+        sMsg = MakeMsg(sMsg, "$Name", MakeMsgA("12%s", plr->GetName()));
+	if(plr->isAFK())
+		sMsg = MakeMsg(sMsg, "$Tag", "<AFK>");
+	else if(plr->isDND())
+		sMsg = MakeMsg(sMsg, "$Tag", "<DND>");
+	else
+		sMsg = MakeMsg(sMsg, "$Tag", "");
+	sMsg = MakeMsg(sMsg, "$Level", MakeMsgA("%d", plr->getLevel()));
+	sMsg = Delink(sMsg);
+	sMsg = WoWcol2IRC(sMsg);
+	return sMsg;
+}
+/*
+std::string MakeMsg(std::string msg, std::string var, int val)
+{
+	std::ostringstream ss;
+    ss << val;
+
+	std::string nval = ss.str();
+    std::size_t start = msg.find(var);
+    if (start != std::string::npos)
+        msg.replace(start, var.length(), val);
+    return msg;
+}
+*/
+/*
+std::string MakeMsg(const char *sLine, ... )
+{
+    va_list ap;
+    char tmpoutp[1024];
+	va_start(ap, sLine);
+	vsnprintf(tmpoutp, 1024, sLine, ap );
+    va_end(ap);
+	std::string outp = tmpoutp;
+	return outp;
+}
+*/
+
+// This function checks if a channel exists in out configuration
+// Mangchat supports as many channels as you like
+// However the default has been set to 10
+// if you wish to increase this you must edit the:
+// MAX_CONF_CHANNELS variable in IRCClient.h
+bool Channel_Valid(std::string Channel)
+{
+	for(int i=1;i < sIRC._chan_count + 1;i++)
+	{
+		if(nocase_cmp(sIRC._wow_chan[i], Channel)==0)
+			return true;
+	}
+	return false;
+}
+
+std::string GetWoWChannel(std::string Channel)
+{
+	for(int i=1;i < sIRC._chan_count + 1;i++)
+	{
+		if("#" + sIRC._irc_chan[i] == Channel)
+			return sIRC._wow_chan[i];
+	}
+	return "";
+}
+
+std::string GetIRCChannel(std::string Channel)
+{
+	for(int i=1;i < sIRC._chan_count + 1;i++)
+	{
+		if(sIRC._wow_chan[i] == Channel)
+			return sIRC._irc_chan[i];
+	}
+	return "";
+}
+
+std::string* getArray(std::string PARAMS, int nCount, std::string )
+{
+	std::string *array = new std::string[nCount];
+	if(PARAMS.size() > 0)
+	{
+		int pcnt = 0;
+		size_t ps = 0;
+		size_t pc = -1;
+		for(int i = 0;i < nCount;i++)
+		{
+			pc = PARAMS.find(" ", pc + 1);
+			if(i + 1 == nCount && nCount != 1)
+			{
+				if(ps > 0 && pc > 0)
+					array[i] = PARAMS.substr(ps, PARAMS.size() - ps);
+			}
+			else
+				array[i] = PARAMS.substr(ps, pc - ps);
+			ps = pc + 1;
+		}
+	}
+	return array;
+}
Index: src/game/IRCIO.cpp
===================================================================
--- src/game/IRCIO.cpp	(revision 0)
+++ src/game/IRCIO.cpp	(revision 0)
@@ -0,0 +1,359 @@
+#include "IRCClient.h"
+#include "IRCCmd.h"
+#include "IRCFunc.h"
+#include "ObjectAccessor.h"
+#include "WorldPacket.h"
+#include "ChannelMgr.h"
+#include "Config/ConfigEnv.h"
+
+IRCCmd Command;
+void IRCClient::Handle_IRC(std::string sData)
+{
+	sLog.outDebug(sData.c_str());
+    // If first 5 chars are ERROR then something is wrong
+	// either link is being closed, nickserv ghost command, etc...
+	if(sData.substr(0, 5) == "ERROR")
+    {
+        	Disconnect();
+    }	    
+	if(sData.substr(0, 4) == "PING")
+    {
+		// if the first 4 characters contain PING
+		// the server is checking if we are still alive
+		// sen back PONG back plus whatever the server send with it
+        SendIRC("PONG " + sData.substr(4, sData.size() - 4));
+    }
+	else
+	{
+		// if the first line contains : its an irc message
+		// such as private messages channel join etc.
+		if(sData.substr(0, 1) == ":")
+		{
+			// find the spaces in the receieved line
+			size_t p1 = sData.find(" ");
+			size_t p2 = sData.find(" ", p1 + 1);
+			// because the irc protocol uses simple spaces
+			// to seperate data we can easy pick them out
+			// since we know the position of the spaces
+			std::string USR = sData.substr(1, p1 - 1);
+			std::string CMD = sData.substr(p1 + 1, p2 - p1 - 1);
+			// trasform the commands to lowercase to make sure they always match
+			std::transform(CMD.begin(), CMD.end(), CMD.begin(), towlower);
+			// Extract the username from the first part
+			std::string szUser = GetUser(USR);
+			// if we receieved the internet connect code
+			// we know for sure that were in and we can
+			// authenticate ourself.
+			if(CMD == sIRC._ICC)
+			{
+				// _Auth is defined in mangosd.conf (irc.auth)
+				// 0 do not authenticate
+				// 1 use nickserv
+				// 2 use quakenet
+				// aditionally you can provide you own authentication method here
+				switch(sIRC._Auth)
+				{
+					case 1:
+						SendIRC("PRIVMSG nickserv :IDENTIFY " + sIRC._Pass);
+						break;
+					case 2:
+						SendIRC("PRIVMSG Q@CServe.quakenet.org :AUTH " + sIRC._Nick + " " + sIRC._Pass);
+						break;
+				}
+				// if we join a default channel leave this now.
+				if(sIRC._ldefc==1)
+					SendIRC("PART #" + sIRC._defchan);
+				// Loop thru the channel array and send a command to join them on IRC.
+				for(int i=1;i < sIRC._chan_count + 1;i++)
+				{
+					SendIRC("JOIN #" + sIRC._irc_chan[i]);
+					Send_IRC_Channel(sIRC._irc_chan[i], sIRC.JoinMsg);
+				}
+			}
+			// IRC Command channel join.
+			// This command is receieved when MangChat joins a channel
+			// or someone else on irc joins the channel
+			if(CMD == "join")
+			{				
+				size_t p = sData.find(":", p1);
+				std::string CHAN = sData.substr(p + 1, sData.size() - p - 2);
+				// if the user is us it means we join the channel
+				if ((szUser == sIRC._Nick) )
+				{
+					// its us that joined the channel
+					Send_IRC_Channel(CHAN, sIRC.JoinMsg, true);
+				}
+				else
+				{
+					// if the user is not us its someone else that joins
+					// so we construct a message and send this to the clients.
+					// MangChat now uses Send_WoW_Channel to send to the client
+					// this makes MangChat handle the packets instead of previously the world.
+					if((sIRC.BOTMASK & 2) != 0)
+				    Send_WoW_Channel(GetWoWChannel(CHAN).c_str(), IRCcol2WoW(MakeMsg(MakeMsg(GetChatLine(JOIN_IRC), "$Name", szUser), "$Channel", GetWoWChannel(CHAN))));
+				}
+			}
+			// someone on irc left the channel
+			if(CMD == "part" || CMD == "quit")
+			{
+				size_t p3 = sData.find(" ", p2 + 1);
+				std::string CHAN = sData.substr(p2 + 1, p3 - p2 - 1);				
+				// Logout IRC Nick From MangChat If User Leaves Or Quits IRC.
+				if(Command.IsLoggedIn(szUser))
+				{
+					_CDATA CDATA;
+					CDATA.USER		= szUser;
+					Command.Handle_Logout(&CDATA);
+				}
+				if((sIRC.BOTMASK & 2) != 0)
+				Send_WoW_Channel(GetWoWChannel(CHAN).c_str(), IRCcol2WoW(MakeMsg(MakeMsg(GetChatLine(LEAVE_IRC), "$Name", szUser), "$Channel", GetWoWChannel(CHAN)))); 
+				// Construct a message and inform the clients on the same channel.
+			}
+			if (CMD == "nick" && (sIRC.BOTMASK & 128) != 0)
+			{
+				MakeMsg(MakeMsg(GetChatLine(CHANGE_NICK), "$Name", szUser), "$NewName", sData.substr(sData.find(":", p2) + 1));
+			}
+			// someone was kicked from irc
+			if (CMD == "kick")
+			{
+				// extract the details
+				size_t p3 = sData.find(" ", p2 + 1);
+				size_t p4 = sData.find(" ", p3 + 1);
+				size_t p5 = sData.find(":", p4);
+				std::string CHAN = sData.substr(p2 + 1, p3 - p2 - 1);
+				std::string WHO = sData.substr(p3 + 1, p4 - p3 - 1);
+				std::string BY = sData.substr(p4 + 1, sData.size() - p4 - 1);
+				// if the one kicked was us
+				if(WHO == sIRC._Nick)
+				{
+					// and autojoin is enabled
+					// return to the channel
+					if(sIRC._autojoinkick == 1)
+					{
+					   SendIRC("JOIN " + CHAN);
+					   Send_IRC_Channel(CHAN, sIRC.kikmsg, true);
+					}
+				}
+				else
+				{
+					// if it is not us who was kicked we need to inform the clients someone
+					// was removed from the channel
+					// construct a message and send it to the players.
+					Send_WoW_Channel(GetWoWChannel(CHAN).c_str(), "<IRC>[" + WHO + "]: Was Kicked From " + CHAN + " By: " + szUser);
+				}
+			}
+			// a chat message was receieved.
+			if(CMD == "privmsg")
+			{
+				// extract the values
+				size_t p = sData.find(" ", p2 + 1);
+				std::string FROM = sData.substr(p2 + 1, p - p2 - 1);
+				std::string CHAT = sData.substr(p + 2, sData.size() - p - 3);
+				// if this is our username it means we recieved a PM
+				if(FROM == sIRC._Nick)
+				{
+					if(CHAT.find("VERSION") < CHAT.size())
+					{
+						Send_IRC_Channel(szUser, "VERSION MangChat v1.0 2007 Cybrax @ VisualDreams, Enhanced By: |Death|", true, MSG_NOTICE);
+					}
+                    // a pm is required for certain commands
+					// such as login. to validate the command
+					// we send it to the command class wich handles
+					// evrything else.
+					Command.IsValid(szUser, FROM, CHAT);
+				}
+				else
+				{
+					// if our name is not in it, it means we receieved chat on one of the channels
+					// magchat is in. the first thing we do is check if it is a command or not
+					if(!Command.IsValid(szUser, FROM, CHAT))
+						Send_WoW_Channel(GetWoWChannel(FROM).c_str(), IRCcol2WoW(MakeMsg(MakeMsg(GetChatLine(IRC_WOW), "$Name", szUser), "$Msg", CHAT)));
+					// if we indeed receieved a command we do not want to display this to the players
+					// so only incanse the isvalid command returns false it will be sent to all player.
+					// the isvalid function will automaitcly process the command on true.
+				}
+			}
+		}
+	}
+}
+// This function is called in Channel.h
+// based on nAction it will inform the people on
+// irc when someone leaves one of the game channels.
+// nAction is based on the struct CACTION
+void IRCClient::Handle_WoW_Channel(std::string Channel, Player *plr, int nAction)
+{
+    // make sure that we are connected
+    if(sIRC.Connected && (sIRC.BOTMASK & 1)!= 0)
+    {
+        if(Channel_Valid(Channel))
+        {
+                std::string GMRank = "";
+				std::string pname = plr->GetName();
+			bool DoGMAnnounce = false;
+			if (plr->GetSession()->GetSecurity() > 0 && (sIRC.BOTMASK & 8)!= 0)
+			    DoGMAnnounce = true;
+			if (plr->isGameMaster() && (sIRC.BOTMASK & 16)!= 0)
+				DoGMAnnounce = true;
+			if(DoGMAnnounce)
+			{
+                switch(plr->GetSession()->GetSecurity())//switch case to determine what rank the "gm" is
+                {
+                    case 0: GMRank = "";break;
+                    case 1: GMRank = sIRC.ojGM1;break;
+                    case 2: GMRank = sIRC.ojGM2;break;
+                    case 3: GMRank = sIRC.ojGM3;break;
+                    case 4: GMRank = sIRC.ojGM4;break;
+                    case 5: GMRank = sIRC.ojGM5;break;
+                }
+            }
+            std::string ChatTag = "";
+            switch (plr->GetTeam())
+            {
+                case 67:ChatTag.append("4");break; //horde
+                case 469:ChatTag.append("12");break; //alliance
+            }
+            std::string query = "INSERT INTO `IRC_Inchan` VALUES (%d,'"+pname+"','"+Channel+"')";
+			std::string lchan = "DELETE FROM `IRC_Inchan` WHERE `guid` = %d AND `channel` = '"+Channel+"'";
+			switch(nAction)
+            {   
+				case CHANNEL_JOIN:
+					Send_IRC_Channel(GetIRCChannel(Channel), ChatTag + MakeMsg(MakeMsg(MakeMsg(GetChatLine(JOIN_WOW), "$Name", plr->GetName()), "$Channel", Channel), "$GM", GMRank));					
+					WorldDatabase.PExecute(lchan.c_str(), plr->GetGUID());
+					WorldDatabase.PExecute(query.c_str(), plr->GetGUID());					
+					break;
+                case CHANNEL_LEAVE:
+                    Send_IRC_Channel(GetIRCChannel(Channel), ChatTag + MakeMsg(MakeMsg(MakeMsg(GetChatLine(LEAVE_WOW), "$Name", plr->GetName()), "$Channel", Channel), "$GM", GMRank));
+                    WorldDatabase.PExecute(lchan.c_str(), plr->GetGUID());
+					break;
+            }
+        }
+    }
+}
+// This function sends chat to a irc channel or user
+// to prevent the # beeing appended to send a msg to a user
+// set the NoPrefix to true
+void IRCClient::Send_IRC_Channel(std::string sChannel, std::string sMsg, bool NoPrefix, int nType)
+{
+	std::string mType = "PRIVMSG";
+	switch(nType)
+	{
+		case MSG_NOTICE:
+			mType = "NOTICE";
+			break;
+		case MSG_ACTION:
+			mType = "ACTION";
+			break;
+	}
+	if(sIRC.Connected)
+	{
+		if(NoPrefix)
+		{
+			if(sChannel.substr(0,1) != "#" && (sIRC.BOTMASK & 32)!= 0)
+				mType = "NOTICE";			
+			SendIRC(mType + " " + sChannel + " :" + sMsg);
+		}
+		else
+			SendIRC(mType + " #" + sChannel + " :" + sMsg);
+	}
+}
+// This function sends a message to all irc channels
+// that mangchat has in its configuration
+void IRCClient::Send_IRC_Channels(std::string sMsg)
+{
+	for(int i=1;i < sIRC._chan_count + 1;i++)
+	{
+		Send_IRC_Channel(sIRC._irc_chan[i], sMsg);
+	}
+}
+// This function is called in ChatHandler.cpp, any channel chat from wow will come
+// to this function, validates the channel and constructs a message that is send to IRC
+void IRCClient::Send_WoW_IRC(Player *plr, std::string Channel, std::string Msg)
+{
+    // Check if the channel exist in our configuration
+    if(Channel_Valid(Channel))
+    {
+		Send_IRC_Channel(GetIRCChannel(Channel), MakeMsgP(WOW_IRC, Msg, plr));
+	}
+}
+void IRCClient::Send_WoW_Player(std::string sPlayer, std::string sMsg)
+{
+	normalizePlayerName(sPlayer);
+	if (Player* plr = ObjectAccessor::Instance().FindPlayerByName(sPlayer.c_str()))
+	{
+		Send_WoW_Player(plr, sMsg);
+	}
+}
+void IRCClient::Send_WoW_Player(Player *plr, string sMsg)
+{
+	WorldPacket data(SMSG_MESSAGECHAT, 200);
+	data << (uint8)CHAT_MSG_SYSTEM;
+	data << (uint32)LANG_UNIVERSAL;
+	data << (uint64)plr->GetGUID();
+	data << (uint32)0;
+	data << (uint64)plr->GetGUID();
+	data << (uint32)(sMsg.length()+1);
+	data << sMsg;
+	data << (uint8)0;
+	plr->GetSession()->SendPacket(&data);
+}
+// This function will construct and send a packet to all players
+// on the given channel ingame. (previuosly found in world.cpp)
+// it loops thru all sessions and checks if they are on the channel
+// if so construct a packet and send it.
+void IRCClient::Send_WoW_Channel(const char *channel, std::string chat)
+{
+	if(!(strlen(channel) > 0))
+		return;
+	HashMapHolder<Player>::MapType& m = ObjectAccessor::Instance().GetPlayers();
+	for(HashMapHolder<Player>::MapType::iterator itr = m.begin(); itr != m.end(); ++itr)
+    {
+        if (itr->second && itr->second->GetSession()->GetPlayer() && itr->second->GetSession()->GetPlayer()->IsInWorld())
+        {
+            if(ChannelMgr* cMgr = channelMgr(itr->second->GetSession()->GetPlayer()->GetTeam()))
+            {
+                if(Channel *chn = cMgr->GetChannel(channel, itr->second->GetSession()->GetPlayer()))
+                {
+                    WorldPacket data;
+		    data.Initialize(SMSG_MESSAGECHAT);
+		    data << (uint8)CHAT_MSG_CHANNEL;
+                    data << (uint32)LANG_UNIVERSAL;
+                    data << (uint64)0;
+                    data << (uint32)0;
+                    data << channel;
+                    data << (uint64)0;
+                    data << (uint32) (strlen(chat.c_str()) + 1);
+                    data << chat.c_str();
+                    data << (uint8)0;
+                    itr->second->GetSession()->SendPacket(&data);
+                }
+            }
+        }
+    }
+}
+void IRCClient::Send_WoW_System(std::string Message)
+{
+	HashMapHolder<Player>::MapType& m = ObjectAccessor::Instance().GetPlayers();
+	for(HashMapHolder<Player>::MapType::iterator itr = m.begin(); itr != m.end(); ++itr)
+    {
+        if (itr->second && itr->second->GetSession()->GetPlayer() && itr->second->GetSession()->GetPlayer()->IsInWorld())
+        {
+            WorldPacket data;
+            data.Initialize(CHAT_MSG_SYSTEM);
+	    data << (uint8)CHAT_MSG_SYSTEM;
+	    data << (uint32)LANG_UNIVERSAL;
+            data << (uint64)0;
+            data << (uint32)0;
+            data << (uint64)0;
+            data << (uint32) (strlen(Message.c_str()) + 1);
+            data << Message.c_str();
+            data << (uint8)0;
+            itr->second->GetSession()->SendPacket(&data);
+        }
+    }
+}
+void IRCClient::ResetIRC()
+{
+	Send_IRC_Channels(sIRC.RstMsg);
+	SendData("QUIT");
+	Disconnect();
+}
Index: src/game/IRCSock.cpp
===================================================================
--- src/game/IRCSock.cpp	(revision 0)
+++ src/game/IRCSock.cpp	(revision 0)
@@ -0,0 +1,129 @@
+#include "IRCClient.h"
+#define MAXDATASIZE 512
+#include <fcntl.h>
+bool IRCClient::InitSock()
+{
+    #ifdef _WIN32
+		WSADATA wsaData; //WSAData
+        if(WSAStartup(MAKEWORD(2,0),&wsaData) != 0)
+        {
+            sLog.outError("IRC Error: Winsock Initialization Error");
+            return false;
+        }
+    #endif
+	if ((sIRC.SOCKET = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP)) == -1)
+    {
+        sLog.outError("IRC Error: Socket Error");
+        return false;
+    }
+    int on = 1;
+    if ( setsockopt ( sIRC.SOCKET, SOL_SOCKET, SO_REUSEADDR, ( const char* ) &on, sizeof ( on ) ) == -1 )
+    {
+        sLog.outError("IRC Error: Invalid Socket");
+        return false;
+    }
+    #ifdef _WIN32
+        u_long iMode = 0;
+        ioctlsocket(sIRC.SOCKET, FIONBIO, &iMode);
+    #else
+        fcntl(sIRC.SOCKET, F_SETFL, O_NONBLOCK);  // set to non-blocking
+        fcntl(sIRC.SOCKET, F_SETFL, O_ASYNC);     // set to asynchronous I/O
+    #endif
+	return true;
+}
+bool IRCClient::Connect(const char *cHost, int nPort)
+{
+	sIRC.Connected = false;
+    struct hostent *he;
+    if ((he=gethostbyname(cHost)) == NULL)
+    {
+		sLog.outError("IRCLIENT: Could not resolve host: %s", cHost);
+        return false;
+    }
+    struct sockaddr_in their_addr;
+    their_addr.sin_family = AF_INET;
+    their_addr.sin_port = htons(nPort);
+    their_addr.sin_addr = *((struct in_addr *)he->h_addr);
+    memset(&(their_addr.sin_zero), '\0', 8);
+	if (::connect(sIRC.SOCKET, (struct sockaddr *)&their_addr, sizeof(struct sockaddr)) == -1)
+    {
+        sLog.outError("IRCLIENT: Cannot connect to %s", cHost);
+        return false;
+    }
+	//FD_ZERO(&sIRC.sfdset);
+	//FD_SET(sIRC.SOCKET,&sIRC.sfdset);
+	sIRC.Connected = true;
+	return true;
+}
+bool IRCClient::Login(std::string sNick, std::string sUser, std::string sPass)
+{
+    char hostname[128];
+    gethostname(hostname, sizeof(hostname));
+	if(SendIRC("HELLO"))
+		if(SendIRC("PASS " + sPass))
+	        if(SendIRC("NICK " + sNick))
+		        if(SendIRC("USER " + sUser + " " + (std::string)hostname + " VisualDreams :MangChat 1.0"))
+				return true;
+	return false;
+}
+bool IRCClient::SendData(const char *data) {
+	if(sIRC.Connected)
+	{
+		if (send(sIRC.SOCKET, data, strlen(data), 0) == -1)
+		{
+			sLog.outError("IRC Error: Socket Receieve ** \n");
+			//Disconnect();
+			return false;
+		}
+	}
+    return true;
+}
+bool IRCClient::SendIRC(std::string data)
+{
+	std::string RealData = data + "\n";
+    return SendData(RealData.c_str());
+}
+void IRCClient::Disconnect()
+{
+	if(sIRC.SOCKET)
+	{
+		#ifdef _WIN32
+			closesocket(sIRC.SOCKET);
+			//WSACleanup();
+		#else
+			close(sIRC.SOCKET);
+		#endif
+	}
+}
+void IRCClient::SockRecv()
+{
+    char szBuffer[MAXDATASIZE];
+
+	#ifdef _WIN32
+	    ZeroMemory(szBuffer,MAXDATASIZE);
+	#else
+		memset(szBuffer, 0, MAXDATASIZE + 1 );
+	#endif
+	int nBytesRecv = ::recv(sIRC.SOCKET, szBuffer, MAXDATASIZE - 1, 0 );
+	if ( nBytesRecv == -1 )
+	{
+		sLog.outError("Connection lost.");
+		sIRC.Connected = false;
+	}
+	else
+	{
+		if (-1 == nBytesRecv)
+		{
+			sLog.outError("Error occurred while receiving from socket.");
+		}
+		else
+		{
+			std::string reply;
+			std::istringstream iss(szBuffer);
+			while(getline(iss, reply))
+			{
+				Handle_IRC(reply);
+			}
+		}
+	}
+}
Index: src/game/Makefile.am
===================================================================
--- src/game/Makefile.am	(revision 4946)
+++ src/game/Makefile.am	(working copy)
@@ -127,7 +127,17 @@
 	IdleMovementGenerator.cpp \
 	IdleMovementGenerator.h \
 	InstanceData.h \
-	Item.cpp \
+	IRCClient.cpp \
+        IRCClient.h \
+        IRCCmd.cpp \
+        IRCCmd.h \
+        IRCCmde.cpp \
+        IRCConf.cpp \
+        IRCConf.h \
+        IRCFunc.h \
+        IRCIO.cpp \
+        IRCSock.cpp \
+        Item.cpp \
 	Item.h \
 	ItemEnchantmentMgr.cpp \
 	ItemEnchantmentMgr.h \
Index: src/mangosd/mangosd.conf.in
===================================================================
--- src/mangosd/mangosd.conf.in	(revision 4946)
+++ src/mangosd/mangosd.conf.in	(working copy)
@@ -496,3 +496,112 @@
 # Default: 1 (enable, required more CPU for work)
 #          0 (disable, less nice position selection but will less CPU use)
 DetectPosCollision = 1
+
+###########################################
+#      MangChat IRC Bot Configuration     #
+###########################################
+#Enable IRC Addon
+irc.active = 1
+
+# IRC ConnectCode
+irc.icc = 001
+
+# IRC Server Host/IP
+irc.host = "irc.freenode.net"
+
+# IRC Server Port
+irc.port = "6667"
+
+# IRC User Name
+irc.user = "MangChat"
+
+# IRC Nickname
+irc.nick = "MangChat"
+
+# IRC Password (Nickserv)
+irc.pass = "NSPASSWORD"
+
+# IRC Auth (0 - Disable) (1 - NickServ) (2 - QuakeNet)
+irc.auth = 1
+
+# Leave A Defined IRC Channel On Server Connect? (0 - Disable) (1- Enable)
+irc.ldef = 0
+
+# IRC Channel To Leave On Server Connect If "irc.ldef = 1"
+irc.defchan = "lobby"
+
+# Time To Wait Before Attemptimg Connection Again (30000 = 30 Seconds)
+irc.wct = 30000
+
+# Maximum Attempts To Try IRC Server.
+irc.maxattempt = 20
+
+# AutoJoin IRC Channel If Kicked? (0 - Disable) (1 - Enable)
+irc.autojoin_kick = 1
+
+# IRC Command Prefix. Ex. (.)online all
+irc.command_prefix = "."
+
+# IRC Channel OnJoin/Restart Messages
+irc.joinmsg = "Whhaaazzzzaaaa, MangChat 1.0 Baby!!"
+irc.rstmsg  = "MangChat Is Restarting, I Will Be Right Back!!"
+irc.kickmsg = "Do Not Kick Me Again, Severe Actions Will Be Taken!"
+
+# IRC Channel To Join For Multiple Channels Un-Comment And Change The Following Lines.. (Channels ARE Case-Sensitive)
+irc.chan_1 = "IRCChannel"
+# irc.chan_2 = "chan2"
+# irc.chan_3 = "chan3"
+# irc.chan_4 = "chan4"
+# irc.chan_5 = "chan5"
+
+# irc.chan_1 Is Linked To wow.chan_1 And So On.. You Can Have Up To 10 Linked Channels.
+
+# WoW Channel To Join. For Multiple Channels Un-Comment And Change The Following Lines.. (Channels ARE Case-Sensitive)
+wow.chan_1 = "world"
+# wow.chan_2 = "LookingForGroup"
+# wow.chan_3 = "chan3"
+# wow.chan_4 = "chan4"
+# wow.chan_5 = "chan5"
+
+# Chat String Configuration
+# wow_irc Is The String Shown In IRC, The Rest Should Be Self-Explanatory
+# You Can Specify Where The GM OnJoin Tag Is Placed By Changing chat.join_wow or chat.leave_wow
+# ***The Tag It Self Can Also Be Changed Below
+chat.wow_irc = "<WoW>[$Name($Level)] $Msg"
+chat.irc_wow = "<IRC>[$Name]: $Msg"
+chat.join_wow = "12>>04 $GM $Name Joined The $Channel Channel!"
+chat.join_irc = "[$Name]: Has Joined IRC!"
+chat.leave_wow = "12<<04 $GM $Name Left The $Channel Channel!"
+chat.leave_irc = "[$Name]: Has Left IRC!"
+chat.change_nick = "<> $Name Is Now Known As $NewName!"
+
+# BotMask - This Defines What The Bot Announces, If Its 0 Everything Is Disabled.
+# ** Simply Add The Values Of The Elements You Want To Create This Mask.
+# *** Ex: WoW join/leaves are 1 and IRC join/leaves are 2, If You Want Both Of These Active And Nothing Else, Then The BotMask is 3.
+# Display WoW Chan Join/Leaves In IRC: 1
+# Display IRC Chan Join/Leaves/NickChanges In WoW: 2
+# Display Unknown Command Message When Trigger Is Used And No Command Exists: 4
+# Announce Security Level > 0 As GM At Login: 8
+# Announce GM In GM ON State AS GM At Login: 16
+# Return All PM Commands To NOTICE Queries: 32
+# Return All Channel Commands To NOTICE Queries: 64
+# Display Nick Changes From IRC In WOW: 128
+Botmask = 255
+
+# ZBUFF Options (Script To Spawn NPC, Then Cast 3 Specified Spells On Player, Then NPC Leaves)
+zbuff.npc = 20692
+zbuff.anim = 23782
+zbuff.spell1 = 25389
+zbuff.spell2 = 10157
+zbuff.spell3 = 25312
+
+###########################################
+# Misc Options
+### Minimum GM Level To Display In Online Command.
+OnlineGM = 3
+### GM Tag To Prefix To GM Onjoin
+irc.gm1 = "[Moderator]"
+irc.gm2 = "[Game Master]"
+irc.gm3 = "[BugTracker]"
+irc.gm4 = "[DevTeam Admin]"
+irc.gm5 = "[SysOP]"
Index: src/mangosd/Master.cpp
===================================================================
--- src/mangosd/Master.cpp	(revision 4946)
+++ src/mangosd/Master.cpp	(working copy)
@@ -37,6 +37,7 @@
 #include "CliRunnable.h"
 #include "RASocket.h"
 #include "ScriptCalls.h"
+#include "../game/IRCClient.h"
 
 #include "Network/TcpSocket.h"
 #include "Network/Utility.h"
@@ -193,6 +194,11 @@
     uint32 numLoops = (sConfig.GetIntDefault( "MaxPingTime", 30 ) * (MINUTE * 1000000 / socketSelecttime));
     uint32 loopCounter = 0;
 
+	// Don't Forget To Add #include "../game/IRCClient.h"
+	ZThread::Thread irc(new IRCClient);
+	irc.setPriority ((ZThread::Priority )2);
+
+
     ///- Wait for termination signal
     while (!World::m_stopEvent)
     {
Index: src/shared/Database/DBCfmt.cpp
===================================================================
--- src/shared/Database/DBCfmt.cpp	(revision 4946)
+++ src/shared/Database/DBCfmt.cpp	(working copy)
@@ -22,7 +22,7 @@
 const char BattlemasterListEntryfmt[]="niiixxxxxiiiixxssssssssssssssssx";
                                                             // data not sorted (more compact store)
 const char ChatChannelsEntryfmt[]="iixssssssssssssssssxxxxxxxxxxxxxxxxxx";
-const char ChrClassesEntryfmt[]="nxixxxxxxxxxxxxxxxxxxxxx";
+const char ChrClassesEntryfmt[]="nxixssssssssssssssssxxxx";
 const char ChrRacesEntryfmt[]="nxixiixxixxxxissssssssssssssssxxxxx";
 const char CreatureDisplayInfofmt[]="nxxxfxxxxxxxxxxxxxxxx";
 const char CreatureFamilyfmt[]="nxxxxxiissssssssssssssssxx";
Index: src/shared/Database/DBCStructure.h
===================================================================
--- src/shared/Database/DBCStructure.h	(revision 4946)
+++ src/shared/Database/DBCStructure.h	(working copy)
@@ -103,7 +103,7 @@
                                                             // 1-2, unused
     uint32      powerType;                                  // 3
                                                             // 4, unused
-    //char*       name[16];                                 // 5-20 unused
+    char*       name[16];                                   // 5-20 unused
                                                             //21 string flag, unused
 };
 
Index: win/mangosdVC71.sln
===================================================================
--- win/mangosdVC71.sln	(revision 4946)
+++ win/mangosdVC71.sln	(working copy)
@@ -1,4 +1,5 @@
-Microsoft Visual Studio Solution File, Format Version 8.00
+Microsoft Visual Studio Solution File, Format Version 9.00
+# Visual Studio 2005
 Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "game", "VC71\game.vcproj", "{1DC6C4DA-A028-41F3-877D-D5400C594F88}"
 	ProjectSection(ProjectDependencies) = postProject
 		{BF6F5D0E-33A5-4E23-9E7D-DD481B7B5B9E} = {BF6F5D0E-33A5-4E23-9E7D-DD481B7B5B9E}
@@ -21,16 +22,10 @@
 	EndProjectSection
 EndProject
 Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "zthread", "VC71\zthread.vcproj", "{262199E8-EEDF-4700-A1D1-E9CC901CF480}"
-	ProjectSection(ProjectDependencies) = postProject
-	EndProjectSection
 EndProject
 Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "zlib", "VC71\zlib.vcproj", "{8F1DEA42-6A5B-4B62-839D-C141A7BFACF2}"
-	ProjectSection(ProjectDependencies) = postProject
-	EndProjectSection
 EndProject
 Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "framework", "VC71\framework.vcproj", "{BF6F5D0E-33A5-4E23-9E7D-DD481B7B5B9E}"
-	ProjectSection(ProjectDependencies) = postProject
-	EndProjectSection
 EndProject
 Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "realmd", "VC71\realmd.vcproj", "{563E9905-3657-460C-AE63-0AC39D162E23}"
 	ProjectSection(ProjectDependencies) = postProject
@@ -46,58 +41,53 @@
 	EndProjectSection
 EndProject
 Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "g3dlite", "VC71\g3dlite.vcproj", "{DE0380F9-C910-4E99-A841-93550D0E61D7}"
-	ProjectSection(ProjectDependencies) = postProject
-	EndProjectSection
 EndProject
 Global
-	GlobalSection(SolutionConfiguration) = preSolution
-		Debug = Debug
-		Release = Release
+	GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		Debug|Win32 = Debug|Win32
+		Release|Win32 = Release|Win32
 	EndGlobalSection
-	GlobalSection(ProjectDependencies) = postSolution
+	GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		{1DC6C4DA-A028-41F3-877D-D5400C594F88}.Debug|Win32.ActiveCfg = Debug|Win32
+		{1DC6C4DA-A028-41F3-877D-D5400C594F88}.Debug|Win32.Build.0 = Debug|Win32
+		{1DC6C4DA-A028-41F3-877D-D5400C594F88}.Release|Win32.ActiveCfg = Release|Win32
+		{1DC6C4DA-A028-41F3-877D-D5400C594F88}.Release|Win32.Build.0 = Release|Win32
+		{90297C34-F231-4DF4-848E-A74BCC0E40ED}.Debug|Win32.ActiveCfg = Debug|Win32
+		{90297C34-F231-4DF4-848E-A74BCC0E40ED}.Debug|Win32.Build.0 = Debug|Win32
+		{90297C34-F231-4DF4-848E-A74BCC0E40ED}.Release|Win32.ActiveCfg = Release|Win32
+		{90297C34-F231-4DF4-848E-A74BCC0E40ED}.Release|Win32.Build.0 = Release|Win32
+		{A3A04E47-43A2-4C08-90B3-029CEF558594}.Debug|Win32.ActiveCfg = Debug|Win32
+		{A3A04E47-43A2-4C08-90B3-029CEF558594}.Debug|Win32.Build.0 = Debug|Win32
+		{A3A04E47-43A2-4C08-90B3-029CEF558594}.Release|Win32.ActiveCfg = Release|Win32
+		{A3A04E47-43A2-4C08-90B3-029CEF558594}.Release|Win32.Build.0 = Release|Win32
+		{262199E8-EEDF-4700-A1D1-E9CC901CF480}.Debug|Win32.ActiveCfg = Debug|Win32
+		{262199E8-EEDF-4700-A1D1-E9CC901CF480}.Debug|Win32.Build.0 = Debug|Win32
+		{262199E8-EEDF-4700-A1D1-E9CC901CF480}.Release|Win32.ActiveCfg = Release|Win32
+		{262199E8-EEDF-4700-A1D1-E9CC901CF480}.Release|Win32.Build.0 = Release|Win32
+		{8F1DEA42-6A5B-4B62-839D-C141A7BFACF2}.Debug|Win32.ActiveCfg = Debug|Win32
+		{8F1DEA42-6A5B-4B62-839D-C141A7BFACF2}.Debug|Win32.Build.0 = Debug|Win32
+		{8F1DEA42-6A5B-4B62-839D-C141A7BFACF2}.Release|Win32.ActiveCfg = Release|Win32
+		{8F1DEA42-6A5B-4B62-839D-C141A7BFACF2}.Release|Win32.Build.0 = Release|Win32
+		{BF6F5D0E-33A5-4E23-9E7D-DD481B7B5B9E}.Debug|Win32.ActiveCfg = Debug|Win32
+		{BF6F5D0E-33A5-4E23-9E7D-DD481B7B5B9E}.Debug|Win32.Build.0 = Debug|Win32
+		{BF6F5D0E-33A5-4E23-9E7D-DD481B7B5B9E}.Release|Win32.ActiveCfg = Release|Win32
+		{BF6F5D0E-33A5-4E23-9E7D-DD481B7B5B9E}.Release|Win32.Build.0 = Release|Win32
+		{563E9905-3657-460C-AE63-0AC39D162E23}.Debug|Win32.ActiveCfg = Debug|Win32
+		{563E9905-3657-460C-AE63-0AC39D162E23}.Debug|Win32.Build.0 = Debug|Win32
+		{563E9905-3657-460C-AE63-0AC39D162E23}.Release|Win32.ActiveCfg = Release|Win32
+		{563E9905-3657-460C-AE63-0AC39D162E23}.Release|Win32.Build.0 = Release|Win32
+		{4205C8A9-79B7-4354-8064-F05FB9CA0C96}.Debug|Win32.ActiveCfg = Debug|Win32
+		{4205C8A9-79B7-4354-8064-F05FB9CA0C96}.Debug|Win32.Build.0 = Debug|Win32
+		{4205C8A9-79B7-4354-8064-F05FB9CA0C96}.Release|Win32.ActiveCfg = Release|Win32
+		{4205C8A9-79B7-4354-8064-F05FB9CA0C96}.Release|Win32.Build.0 = Release|Win32
+		{DE0380F9-C910-4E99-A841-93550D0E61D7}.Debug|Win32.ActiveCfg = Debug|Win32
+		{DE0380F9-C910-4E99-A841-93550D0E61D7}.Debug|Win32.Build.0 = Debug|Win32
+		{DE0380F9-C910-4E99-A841-93550D0E61D7}.Release|Win32.ActiveCfg = Release|Win32
+		{DE0380F9-C910-4E99-A841-93550D0E61D7}.Release|Win32.Build.0 = Release|Win32
 	EndGlobalSection
-	GlobalSection(ProjectConfiguration) = postSolution
-		{1DC6C4DA-A028-41F3-877D-D5400C594F88}.Debug.ActiveCfg = Debug|Win32
-		{1DC6C4DA-A028-41F3-877D-D5400C594F88}.Debug.Build.0 = Debug|Win32
-		{1DC6C4DA-A028-41F3-877D-D5400C594F88}.Release.ActiveCfg = Release|Win32
-		{1DC6C4DA-A028-41F3-877D-D5400C594F88}.Release.Build.0 = Release|Win32
-		{90297C34-F231-4DF4-848E-A74BCC0E40ED}.Debug.ActiveCfg = Debug|Win32
-		{90297C34-F231-4DF4-848E-A74BCC0E40ED}.Debug.Build.0 = Debug|Win32
-		{90297C34-F231-4DF4-848E-A74BCC0E40ED}.Release.ActiveCfg = Release|Win32
-		{90297C34-F231-4DF4-848E-A74BCC0E40ED}.Release.Build.0 = Release|Win32
-		{A3A04E47-43A2-4C08-90B3-029CEF558594}.Debug.ActiveCfg = Debug|Win32
-		{A3A04E47-43A2-4C08-90B3-029CEF558594}.Debug.Build.0 = Debug|Win32
-		{A3A04E47-43A2-4C08-90B3-029CEF558594}.Release.ActiveCfg = Release|Win32
-		{A3A04E47-43A2-4C08-90B3-029CEF558594}.Release.Build.0 = Release|Win32
-		{262199E8-EEDF-4700-A1D1-E9CC901CF480}.Debug.ActiveCfg = Debug|Win32
-		{262199E8-EEDF-4700-A1D1-E9CC901CF480}.Debug.Build.0 = Debug|Win32
-		{262199E8-EEDF-4700-A1D1-E9CC901CF480}.Release.ActiveCfg = Release|Win32
-		{262199E8-EEDF-4700-A1D1-E9CC901CF480}.Release.Build.0 = Release|Win32
-		{8F1DEA42-6A5B-4B62-839D-C141A7BFACF2}.Debug.ActiveCfg = Debug|Win32
-		{8F1DEA42-6A5B-4B62-839D-C141A7BFACF2}.Debug.Build.0 = Debug|Win32
-		{8F1DEA42-6A5B-4B62-839D-C141A7BFACF2}.Release.ActiveCfg = Release|Win32
-		{8F1DEA42-6A5B-4B62-839D-C141A7BFACF2}.Release.Build.0 = Release|Win32
-		{BF6F5D0E-33A5-4E23-9E7D-DD481B7B5B9E}.Debug.ActiveCfg = Debug|Win32
-		{BF6F5D0E-33A5-4E23-9E7D-DD481B7B5B9E}.Debug.Build.0 = Debug|Win32
-		{BF6F5D0E-33A5-4E23-9E7D-DD481B7B5B9E}.Release.ActiveCfg = Release|Win32
-		{BF6F5D0E-33A5-4E23-9E7D-DD481B7B5B9E}.Release.Build.0 = Release|Win32
-		{563E9905-3657-460C-AE63-0AC39D162E23}.Debug.ActiveCfg = Debug|Win32
-		{563E9905-3657-460C-AE63-0AC39D162E23}.Debug.Build.0 = Debug|Win32
-		{563E9905-3657-460C-AE63-0AC39D162E23}.Release.ActiveCfg = Release|Win32
-		{563E9905-3657-460C-AE63-0AC39D162E23}.Release.Build.0 = Release|Win32
-		{4205C8A9-79B7-4354-8064-F05FB9CA0C96}.Debug.ActiveCfg = Debug|Win32
-		{4205C8A9-79B7-4354-8064-F05FB9CA0C96}.Debug.Build.0 = Debug|Win32
-		{4205C8A9-79B7-4354-8064-F05FB9CA0C96}.Release.ActiveCfg = Release|Win32
-		{4205C8A9-79B7-4354-8064-F05FB9CA0C96}.Release.Build.0 = Release|Win32
-		{DE0380F9-C910-4E99-A841-93550D0E61D7}.Debug.ActiveCfg = Debug|Win32
-		{DE0380F9-C910-4E99-A841-93550D0E61D7}.Debug.Build.0 = Debug|Win32
-		{DE0380F9-C910-4E99-A841-93550D0E61D7}.Release.ActiveCfg = Release|Win32
-		{DE0380F9-C910-4E99-A841-93550D0E61D7}.Release.Build.0 = Release|Win32
+	GlobalSection(SolutionProperties) = preSolution
+		HideSolutionNode = FALSE
 	EndGlobalSection
-	GlobalSection(ExtensibilityGlobals) = postSolution
-	EndGlobalSection
-	GlobalSection(ExtensibilityAddIns) = postSolution
-	EndGlobalSection
 	GlobalSection(DPCodeReviewSolutionGUID) = preSolution
 		DPCodeReviewSolutionGUID = {00000000-0000-0000-0000-000000000000}
 	EndGlobalSection
Index: win/mangosdVC80.sln
===================================================================
--- win/mangosdVC80.sln	(revision 4946)
+++ win/mangosdVC80.sln	(working copy)
@@ -7,10 +7,10 @@
 EndProject
 Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "shared", "VC80\shared.vcproj", "{90297C34-F231-4DF4-848E-A74BCC0E40ED}"
 	ProjectSection(ProjectDependencies) = postProject
+		{BF6F5D0E-33A5-4E23-9E7D-DD481B7B5B9E} = {BF6F5D0E-33A5-4E23-9E7D-DD481B7B5B9E}
+		{8F1DEA42-6A5B-4B62-839D-C141A7BFACF2} = {8F1DEA42-6A5B-4B62-839D-C141A7BFACF2}
+		{8072769E-CF10-48BF-B9E1-12752A5DAC6E} = {8072769E-CF10-48BF-B9E1-12752A5DAC6E}
 		{262199E8-EEDF-4700-A1D1-E9CC901CF480} = {262199E8-EEDF-4700-A1D1-E9CC901CF480}
-		{8072769E-CF10-48BF-B9E1-12752A5DAC6E} = {8072769E-CF10-48BF-B9E1-12752A5DAC6E}
-		{8F1DEA42-6A5B-4B62-839D-C141A7BFACF2} = {8F1DEA42-6A5B-4B62-839D-C141A7BFACF2}
-		{BF6F5D0E-33A5-4E23-9E7D-DD481B7B5B9E} = {BF6F5D0E-33A5-4E23-9E7D-DD481B7B5B9E}
 	EndProjectSection
 EndProject
 Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "mangosd", "VC80\mangosd.vcproj", "{A3A04E47-43A2-4C08-90B3-029CEF558594}"
Index: win/VC71/game.vcproj
===================================================================
--- win/VC71/game.vcproj	(revision 4946)
+++ win/VC71/game.vcproj	(working copy)
@@ -1,817 +1,1133 @@
 <?xml version="1.0" encoding="Windows-1252"?>
 <VisualStudioProject
 	ProjectType="Visual C++"
-	Version="7.10"
+	Version="8.00"
 	Name="game"
-	ProjectGUID="{622DAAB0-B843-4B19-AEFC-693456DF95D8}"
-	SccProjectName=""
-	SccLocalPath="">
+	ProjectGUID="{1DC6C4DA-A028-41F3-877D-D5400C594F88}"
+	RootNamespace="game"
+	>
 	<Platforms>
 		<Platform
-			Name="Win32"/>
+			Name="Win32"
+		/>
 	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
 	<Configurations>
 		<Configuration
 			Name="Debug|Win32"
 			OutputDirectory=".\game__$(PlatformName)_$(ConfigurationName)"
 			IntermediateDirectory=".\game__$(PlatformName)_$(ConfigurationName)"
 			ConfigurationType="4"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC71.vsprops"
 			UseOfMFC="0"
-			ATLMinimizesCRunTimeLibraryUsage="FALSE"
-			CharacterSet="2">
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			CharacterSet="2"
+			>
 			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
 				Name="VCCLCompilerTool"
 				Optimization="0"
 				AdditionalIncludeDirectories="..\..\dep\include;..\..\src\shared\vmap;..\..\src\framework;..\..\src\shared"
 				PreprocessorDefinitions="WIN32;_DEBUG;MANGOS_DEBUG;_LIB;"
-				StringPooling="FALSE"
-				MinimalRebuild="FALSE"
+				StringPooling="false"
+				MinimalRebuild="false"
 				BasicRuntimeChecks="3"
 				RuntimeLibrary="1"
-				RuntimeTypeInfo="TRUE"
-				UsePrecompiledHeader="2"
+				RuntimeTypeInfo="true"
+				UsePrecompiledHeader="0"
 				PrecompiledHeaderFile=".\game__$(PlatformName)_$(ConfigurationName)\game.pch"
 				AssemblerListingLocation=".\game__$(PlatformName)_$(ConfigurationName)\"
 				ObjectFile=".\game__$(PlatformName)_$(ConfigurationName)\"
 				ProgramDataBaseFileName=".\game__$(PlatformName)_$(ConfigurationName)\"
 				WarningLevel="3"
-				SuppressStartupBanner="TRUE"
-				Detect64BitPortabilityProblems="TRUE"
+				SuppressStartupBanner="true"
+				Detect64BitPortabilityProblems="true"
 				DebugInformationFormat="3"
-				CompileAs="0"/>
+				CompileAs="0"
+			/>
 			<Tool
-				Name="VCCustomBuildTool"/>
+				Name="VCManagedResourceCompilerTool"
+			/>
 			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="_DEBUG"
+				Culture="1033"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
 				Name="VCLibrarianTool"
 				AdditionalDependencies=".\shared__$(PlatformName)_$(ConfigurationName)\shared.lib"
 				OutputFile=".\game__$(PlatformName)_$(ConfigurationName)\game.lib"
-				SuppressStartupBanner="TRUE"/>
+				SuppressStartupBanner="true"
+			/>
 			<Tool
-				Name="VCMIDLTool"/>
+				Name="VCALinkTool"
+			/>
 			<Tool
-				Name="VCPostBuildEventTool"/>
+				Name="VCXDCMakeTool"
+			/>
 			<Tool
-				Name="VCPreBuildEventTool"/>
+				Name="VCBscMakeTool"
+			/>
 			<Tool
-				Name="VCPreLinkEventTool"/>
+				Name="VCFxCopTool"
+			/>
 			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="_DEBUG"
-				Culture="1033"/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"/>
-			<Tool
-				Name="VCManagedWrapperGeneratorTool"/>
-			<Tool
-				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+				Name="VCPostBuildEventTool"
+			/>
 		</Configuration>
 		<Configuration
 			Name="Release|Win32"
 			OutputDirectory=".\game__$(PlatformName)_$(ConfigurationName)"
 			IntermediateDirectory=".\game__$(PlatformName)_$(ConfigurationName)"
 			ConfigurationType="4"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC71.vsprops"
 			UseOfMFC="0"
-			ATLMinimizesCRunTimeLibraryUsage="FALSE"
-			CharacterSet="2">
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			CharacterSet="2"
+			>
 			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
 				Name="VCCLCompilerTool"
 				InlineFunctionExpansion="1"
 				AdditionalIncludeDirectories="..\..\dep\include;..\..\src\shared\vmap;..\..\src\framework;..\..\src\shared"
 				PreprocessorDefinitions="WIN32;NDEBUG;_LIB"
-				StringPooling="TRUE"
+				StringPooling="true"
 				RuntimeLibrary="0"
-				EnableFunctionLevelLinking="TRUE"
+				EnableFunctionLevelLinking="true"
 				EnableEnhancedInstructionSet="1"
-				RuntimeTypeInfo="TRUE"
-				UsePrecompiledHeader="2"
+				RuntimeTypeInfo="true"
+				UsePrecompiledHeader="0"
 				PrecompiledHeaderFile=".\game__$(PlatformName)_$(ConfigurationName)\game.pch"
 				AssemblerListingLocation=".\game__$(PlatformName)_$(ConfigurationName)\"
 				ObjectFile=".\game__$(PlatformName)_$(ConfigurationName)\"
 				ProgramDataBaseFileName=".\game__$(PlatformName)_$(ConfigurationName)\"
 				WarningLevel="3"
-				SuppressStartupBanner="TRUE"
-				Detect64BitPortabilityProblems="TRUE"
+				SuppressStartupBanner="true"
+				Detect64BitPortabilityProblems="true"
 				DebugInformationFormat="3"
-				CompileAs="0"/>
+				CompileAs="0"
+			/>
 			<Tool
-				Name="VCCustomBuildTool"/>
+				Name="VCManagedResourceCompilerTool"
+			/>
 			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="NDEBUG"
+				Culture="1033"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
 				Name="VCLibrarianTool"
 				AdditionalDependencies=".\shared__$(PlatformName)_$(ConfigurationName)\shared.lib"
 				OutputFile=".\game__$(PlatformName)_$(ConfigurationName)\game.lib"
-				SuppressStartupBanner="TRUE"/>
+				SuppressStartupBanner="true"
+			/>
 			<Tool
-				Name="VCMIDLTool"/>
+				Name="VCALinkTool"
+			/>
 			<Tool
-				Name="VCPostBuildEventTool"/>
+				Name="VCXDCMakeTool"
+			/>
 			<Tool
-				Name="VCPreBuildEventTool"/>
+				Name="VCBscMakeTool"
+			/>
 			<Tool
-				Name="VCPreLinkEventTool"/>
+				Name="VCFxCopTool"
+			/>
 			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="NDEBUG"
-				Culture="1033"/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"/>
-			<Tool
-				Name="VCManagedWrapperGeneratorTool"/>
-			<Tool
-				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+				Name="VCPostBuildEventTool"
+			/>
 		</Configuration>
 	</Configurations>
 	<References>
 	</References>
 	<Files>
 		<Filter
-			Name="World/Handlers">
+			Name="World/Handlers"
+			>
 			<File
-				RelativePath="..\..\src\game\AccountMgr.cpp">
+				RelativePath="..\..\src\game\AccountMgr.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\AccountMgr.h">
+				RelativePath="..\..\src\game\AccountMgr.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\AddonHandler.cpp">
+				RelativePath="..\..\src\game\AddonHandler.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\AddonHandler.h">
+				RelativePath="..\..\src\game\AddonHandler.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\ArenaTeamHandler.cpp">
+				RelativePath="..\..\src\game\ArenaTeamHandler.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\AuctionHouse.cpp">
+				RelativePath="..\..\src\game\AuctionHouse.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\BattleGround.cpp">
+				RelativePath="..\..\src\game\BattleGround.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\BattleGround.h">
+				RelativePath="..\..\src\game\BattleGround.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\BattleGroundAA.cpp">
+				RelativePath="..\..\src\game\BattleGroundAA.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\BattleGroundAA.h">
+				RelativePath="..\..\src\game\BattleGroundAA.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\BattleGroundAB.cpp">
+				RelativePath="..\..\src\game\BattleGroundAB.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\BattleGroundAB.h">
+				RelativePath="..\..\src\game\BattleGroundAB.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\BattleGroundAV.cpp">
+				RelativePath="..\..\src\game\BattleGroundAV.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\BattleGroundAV.h">
+				RelativePath="..\..\src\game\BattleGroundAV.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\BattleGroundBE.cpp">
+				RelativePath="..\..\src\game\BattleGroundBE.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\BattleGroundBE.h">
+				RelativePath="..\..\src\game\BattleGroundBE.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\BattleGroundEY.cpp">
+				RelativePath="..\..\src\game\BattleGroundEY.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\BattleGroundEY.h">
+				RelativePath="..\..\src\game\BattleGroundEY.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\BattleGroundHandler.cpp">
+				RelativePath="..\..\src\game\BattleGroundHandler.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\BattleGroundMgr.cpp">
+				RelativePath="..\..\src\game\BattleGroundMgr.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\BattleGroundMgr.h">
+				RelativePath="..\..\src\game\BattleGroundMgr.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\BattleGroundNA.cpp">
+				RelativePath="..\..\src\game\BattleGroundNA.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\BattleGroundNA.h">
+				RelativePath="..\..\src\game\BattleGroundNA.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\BattleGroundRL.cpp">
+				RelativePath="..\..\src\game\BattleGroundRL.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\BattleGroundRL.h">
+				RelativePath="..\..\src\game\BattleGroundRL.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\BattleGroundWS.cpp">
+				RelativePath="..\..\src\game\BattleGroundWS.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\BattleGroundWS.h">
+				RelativePath="..\..\src\game\BattleGroundWS.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\Cell.h">
+				RelativePath="..\..\src\game\Cell.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\CellImpl.h">
+				RelativePath="..\..\src\game\CellImpl.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\Channel.cpp">
+				RelativePath="..\..\src\game\Channel.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\Channel.h">
+				RelativePath="..\..\src\game\Channel.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\ChannelHandler.cpp">
+				RelativePath="..\..\src\game\ChannelHandler.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\ChannelMgr.h">
+				RelativePath="..\..\src\game\ChannelMgr.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\CharacterHandler.cpp">
+				RelativePath="..\..\src\game\CharacterHandler.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\Chat.cpp">
+				RelativePath="..\..\src\game\Chat.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\Chat.h">
+				RelativePath="..\..\src\game\Chat.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\ChatHandler.cpp">
+				RelativePath="..\..\src\game\ChatHandler.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\CombatHandler.cpp">
+				RelativePath="..\..\src\game\CombatHandler.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\DuelHandler.cpp">
+				RelativePath="..\..\src\game\DuelHandler.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\GameEvent.cpp">
+				RelativePath="..\..\src\game\GameEvent.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\GameEvent.h">
+				RelativePath="..\..\src\game\GameEvent.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\GossipDef.cpp">
+				RelativePath="..\..\src\game\GossipDef.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\GossipDef.h">
+				RelativePath="..\..\src\game\GossipDef.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\GridDefines.h">
+				RelativePath="..\..\src\game\GridDefines.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\GridNotifiers.cpp">
+				RelativePath="..\..\src\game\GridNotifiers.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\GridNotifiers.h">
+				RelativePath="..\..\src\game\GridNotifiers.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\GridNotifiersImpl.h">
+				RelativePath="..\..\src\game\GridNotifiersImpl.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\GridStates.cpp">
+				RelativePath="..\..\src\game\GridStates.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\GridStates.h">
+				RelativePath="..\..\src\game\GridStates.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\Group.cpp">
+				RelativePath="..\..\src\game\Group.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\Group.h">
+				RelativePath="..\..\src\game\Group.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\GroupHandler.cpp">
+				RelativePath="..\..\src\game\GroupHandler.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\GuildHandler.cpp">
+				RelativePath="..\..\src\game\GuildHandler.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\InstanceData.h">
+				RelativePath="..\..\src\game\InstanceData.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\ItemHandler.cpp">
+				RelativePath="..\..\src\game\ItemHandler.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\LFGHandler.cpp">
+				RelativePath="..\..\src\game\LFGHandler.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\LootHandler.cpp">
+				RelativePath="..\..\src\game\LootHandler.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\Mail.cpp">
+				RelativePath="..\..\src\game\Mail.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\Mail.h">
+				RelativePath="..\..\src\game\Mail.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\Map.cpp">
+				RelativePath="..\..\src\game\Map.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\Map.h">
+				RelativePath="..\..\src\game\Map.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\MapInstanced.cpp">
+				RelativePath="..\..\src\game\MapInstanced.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\MapInstanced.h">
+				RelativePath="..\..\src\game\MapInstanced.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\MapManager.cpp">
+				RelativePath="..\..\src\game\MapManager.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\MapManager.h">
+				RelativePath="..\..\src\game\MapManager.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\MiscHandler.cpp">
+				RelativePath="..\..\src\game\MiscHandler.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\MovementHandler.cpp">
+				RelativePath="..\..\src\game\MovementHandler.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\NPCHandler.cpp">
+				RelativePath="..\..\src\game\NPCHandler.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\NPCHandler.h">
+				RelativePath="..\..\src\game\NPCHandler.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\ObjectGridLoader.cpp">
+				RelativePath="..\..\src\game\ObjectGridLoader.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\ObjectGridLoader.h">
+				RelativePath="..\..\src\game\ObjectGridLoader.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\Path.h">
+				RelativePath="..\..\src\game\Path.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\PetHandler.cpp">
+				RelativePath="..\..\src\game\PetHandler.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\PetitionsHandler.cpp">
+				RelativePath="..\..\src\game\PetitionsHandler.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\QueryHandler.cpp">
+				RelativePath="..\..\src\game\QueryHandler.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\QuestDef.cpp">
+				RelativePath="..\..\src\game\QuestDef.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\QuestDef.h">
+				RelativePath="..\..\src\game\QuestDef.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\QuestHandler.cpp">
+				RelativePath="..\..\src\game\QuestHandler.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\ScriptCalls.cpp">
+				RelativePath="..\..\src\game\ScriptCalls.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\ScriptCalls.h">
+				RelativePath="..\..\src\game\ScriptCalls.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\SkillDiscovery.cpp">
+				RelativePath="..\..\src\game\SkillDiscovery.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\SkillDiscovery.h">
+				RelativePath="..\..\src\game\SkillDiscovery.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\SkillHandler.cpp">
+				RelativePath="..\..\src\game\SkillHandler.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\Spell.cpp">
+				RelativePath="..\..\src\game\Spell.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\Spell.h">
+				RelativePath="..\..\src\game\Spell.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\SpellAuraDefines.h">
+				RelativePath="..\..\src\game\SpellAuraDefines.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\SpellAuras.cpp">
+				RelativePath="..\..\src\game\SpellAuras.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\SpellAuras.h">
+				RelativePath="..\..\src\game\SpellAuras.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\SpellEffects.cpp">
+				RelativePath="..\..\src\game\SpellEffects.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\SpellHandler.cpp">
+				RelativePath="..\..\src\game\SpellHandler.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\TaxiHandler.cpp">
+				RelativePath="..\..\src\game\TaxiHandler.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\TradeHandler.cpp">
+				RelativePath="..\..\src\game\TradeHandler.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\Transports.cpp">
+				RelativePath="..\..\src\game\Transports.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\Transports.h">
+				RelativePath="..\..\src\game\Transports.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\UpdateData.cpp">
+				RelativePath="..\..\src\game\UpdateData.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\UpdateData.h">
+				RelativePath="..\..\src\game\UpdateData.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\VoiceChatHandler.cpp">
+				RelativePath="..\..\src\game\VoiceChatHandler.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\Weather.cpp">
+				RelativePath="..\..\src\game\Weather.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\Weather.h">
+				RelativePath="..\..\src\game\Weather.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\World.cpp">
+				RelativePath="..\..\src\game\World.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\World.h">
+				RelativePath="..\..\src\game\World.h"
+				>
 			</File>
 		</Filter>
 		<Filter
-			Name="Object">
+			Name="Object"
+			>
 			<File
-				RelativePath="..\..\src\game\AggressorAI.cpp">
+				RelativePath="..\..\src\game\AggressorAI.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\AggressorAI.h">
+				RelativePath="..\..\src\game\AggressorAI.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\AnimalRandomMovementGenerator.h">
+				RelativePath="..\..\src\game\AnimalRandomMovementGenerator.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\ArenaTeam.cpp">
+				RelativePath="..\..\src\game\ArenaTeam.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\ArenaTeam.h">
+				RelativePath="..\..\src\game\ArenaTeam.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\AuctionHouseObject.h">
+				RelativePath="..\..\src\game\AuctionHouseObject.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\Bag.cpp">
+				RelativePath="..\..\src\game\Bag.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\Bag.h">
+				RelativePath="..\..\src\game\Bag.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\ConfusedMovementGenerator.cpp">
+				RelativePath="..\..\src\game\ConfusedMovementGenerator.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\ConfusedMovementGenerator.h">
+				RelativePath="..\..\src\game\ConfusedMovementGenerator.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\Corpse.cpp">
+				RelativePath="..\..\src\game\Corpse.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\Corpse.h">
+				RelativePath="..\..\src\game\Corpse.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\Creature.cpp">
+				RelativePath="..\..\src\game\Creature.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\Creature.h">
+				RelativePath="..\..\src\game\Creature.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\CreatureAI.cpp">
+				RelativePath="..\..\src\game\CreatureAI.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\CreatureAI.h">
+				RelativePath="..\..\src\game\CreatureAI.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\CreatureAIImpl.h">
+				RelativePath="..\..\src\game\CreatureAIImpl.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\CreatureAIRegistry.cpp">
+				RelativePath="..\..\src\game\CreatureAIRegistry.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\CreatureAIRegistry.h">
+				RelativePath="..\..\src\game\CreatureAIRegistry.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\CreatureAISelector.cpp">
+				RelativePath="..\..\src\game\CreatureAISelector.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\CreatureAISelector.h">
+				RelativePath="..\..\src\game\CreatureAISelector.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\DestinationHolder.cpp">
+				RelativePath="..\..\src\game\DestinationHolder.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\DestinationHolder.h">
+				RelativePath="..\..\src\game\DestinationHolder.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\DestinationHolderImp.h">
+				RelativePath="..\..\src\game\DestinationHolderImp.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\DynamicObject.cpp">
+				RelativePath="..\..\src\game\DynamicObject.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\DynamicObject.h">
+				RelativePath="..\..\src\game\DynamicObject.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\Formulas.h">
+				RelativePath="..\..\src\game\Formulas.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\GameObject.cpp">
+				RelativePath="..\..\src\game\GameObject.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\GameObject.h">
+				RelativePath="..\..\src\game\GameObject.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\GuardAI.cpp">
+				RelativePath="..\..\src\game\GuardAI.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\GuardAI.h">
+				RelativePath="..\..\src\game\GuardAI.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\Guild.cpp">
+				RelativePath="..\..\src\game\Guild.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\Guild.h">
+				RelativePath="..\..\src\game\Guild.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\HateMatrix.h">
+				RelativePath="..\..\src\game\HateMatrix.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\HomeMovementGenerator.cpp">
+				RelativePath="..\..\src\game\HomeMovementGenerator.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\HomeMovementGenerator.h">
+				RelativePath="..\..\src\game\HomeMovementGenerator.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\IdleMovementGenerator.cpp">
+				RelativePath="..\..\src\game\IdleMovementGenerator.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\IdleMovementGenerator.h">
+				RelativePath="..\..\src\game\IdleMovementGenerator.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\Item.cpp">
+				RelativePath="..\..\src\game\Item.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\Item.h">
+				RelativePath="..\..\src\game\Item.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\ItemEnchantmentMgr.cpp">
+				RelativePath="..\..\src\game\ItemEnchantmentMgr.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\ItemEnchantmentMgr.h">
+				RelativePath="..\..\src\game\ItemEnchantmentMgr.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\ItemPrototype.h">
+				RelativePath="..\..\src\game\ItemPrototype.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\LootMgr.cpp">
+				RelativePath="..\..\src\game\LootMgr.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\LootMgr.h">
+				RelativePath="..\..\src\game\LootMgr.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\MotionMaster.cpp">
+				RelativePath="..\..\src\game\MotionMaster.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\MotionMaster.h">
+				RelativePath="..\..\src\game\MotionMaster.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\MovementGenerator.cpp">
+				RelativePath="..\..\src\game\MovementGenerator.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\MovementGenerator.h">
+				RelativePath="..\..\src\game\MovementGenerator.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\NullCreatureAI.cpp">
+				RelativePath="..\..\src\game\NullCreatureAI.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\NullCreatureAI.h">
+				RelativePath="..\..\src\game\NullCreatureAI.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\Object.cpp">
+				RelativePath="..\..\src\game\Object.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\Object.h">
+				RelativePath="..\..\src\game\Object.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\ObjectAccessor.cpp">
+				RelativePath="..\..\src\game\ObjectAccessor.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\ObjectAccessor.h">
+				RelativePath="..\..\src\game\ObjectAccessor.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\ObjectDefines.h">
+				RelativePath="..\..\src\game\ObjectDefines.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\ObjectMgr.cpp">
+				RelativePath="..\..\src\game\ObjectMgr.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\ObjectMgr.h">
+				RelativePath="..\..\src\game\ObjectMgr.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\ObjectPosSelector.cpp">
+				RelativePath="..\..\src\game\ObjectPosSelector.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\ObjectPosSelector.h">
+				RelativePath="..\..\src\game\ObjectPosSelector.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\Pet.cpp">
+				RelativePath="..\..\src\game\Pet.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\Pet.h">
+				RelativePath="..\..\src\game\Pet.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\PetAI.cpp">
+				RelativePath="..\..\src\game\PetAI.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\PetAI.h">
+				RelativePath="..\..\src\game\PetAI.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\Player.cpp">
+				RelativePath="..\..\src\game\Player.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\Player.h">
+				RelativePath="..\..\src\game\Player.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\RandomMovementGenerator.cpp">
+				RelativePath="..\..\src\game\RandomMovementGenerator.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\RandomMovementGenerator.h">
+				RelativePath="..\..\src\game\RandomMovementGenerator.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\ReactorAI.cpp">
+				RelativePath="..\..\src\game\ReactorAI.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\ReactorAI.h">
+				RelativePath="..\..\src\game\ReactorAI.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\RedZoneDistrict.cpp">
+				RelativePath="..\..\src\game\RedZoneDistrict.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\RedZoneDistrict.h">
+				RelativePath="..\..\src\game\RedZoneDistrict.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\StatSystem.cpp">
+				RelativePath="..\..\src\game\StatSystem.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\TargetedMovementGenerator.cpp">
+				RelativePath="..\..\src\game\TargetedMovementGenerator.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\TargetedMovementGenerator.h">
+				RelativePath="..\..\src\game\TargetedMovementGenerator.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\TemporarySummon.cpp">
+				RelativePath="..\..\src\game\TemporarySummon.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\TemporarySummon.h">
+				RelativePath="..\..\src\game\TemporarySummon.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\Totem.cpp">
+				RelativePath="..\..\src\game\Totem.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\Totem.h">
+				RelativePath="..\..\src\game\Totem.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\TotemAI.cpp">
+				RelativePath="..\..\src\game\TotemAI.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\TotemAI.h">
+				RelativePath="..\..\src\game\TotemAI.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\Traveller.h">
+				RelativePath="..\..\src\game\Traveller.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\Unit.cpp">
+				RelativePath="..\..\src\game\Unit.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\Unit.h">
+				RelativePath="..\..\src\game\Unit.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\UnitEvents.h">
+				RelativePath="..\..\src\game\UnitEvents.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\UpdateFields.h">
+				RelativePath="..\..\src\game\UpdateFields.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\UpdateMask.h">
+				RelativePath="..\..\src\game\UpdateMask.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\WaypointMovementGenerator.cpp">
+				RelativePath="..\..\src\game\WaypointMovementGenerator.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\WaypointMovementGenerator.h">
+				RelativePath="..\..\src\game\WaypointMovementGenerator.h"
+				>
 			</File>
 		</Filter>
 		<Filter
-			Name="Server">
+			Name="Server"
+			>
 			<File
-				RelativePath="..\..\src\game\GlobalEvents.cpp">
+				RelativePath="..\..\src\game\GlobalEvents.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\GlobalEvents.h">
+				RelativePath="..\..\src\game\GlobalEvents.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\NameTables.h">
+				RelativePath="..\..\src\game\NameTables.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\Opcodes.cpp">
+				RelativePath="..\..\src\game\Opcodes.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\Opcodes.h">
+				RelativePath="..\..\src\game\Opcodes.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\SharedDefines.h">
+				RelativePath="..\..\src\game\SharedDefines.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\WorldLog.cpp">
+				RelativePath="..\..\src\game\WorldLog.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\WorldLog.h">
+				RelativePath="..\..\src\game\WorldLog.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\WorldSession.cpp">
+				RelativePath="..\..\src\game\WorldSession.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\WorldSession.h">
+				RelativePath="..\..\src\game\WorldSession.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\WorldSocket.cpp">
+				RelativePath="..\..\src\game\WorldSocket.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\WorldSocket.h">
+				RelativePath="..\..\src\game\WorldSocket.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\WorldSocketMgr.cpp">
+				RelativePath="..\..\src\game\WorldSocketMgr.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\WorldSocketMgr.h">
+				RelativePath="..\..\src\game\WorldSocketMgr.h"
+				>
 			</File>
 		</Filter>
 		<Filter
-			Name="Chat Commands">
+			Name="Chat Commands"
+			>
 			<File
-				RelativePath="..\..\src\game\debugcmds.cpp">
+				RelativePath="..\..\src\game\debugcmds.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\Level0.cpp">
+				RelativePath="..\..\src\game\Level0.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\Level1.cpp">
+				RelativePath="..\..\src\game\Level1.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\Level2.cpp">
+				RelativePath="..\..\src\game\Level2.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\Level3.cpp">
+				RelativePath="..\..\src\game\Level3.cpp"
+				>
 			</File>
 		</Filter>
 		<Filter
-			Name="Tool">
+			Name="Tool"
+			>
 			<File
-				RelativePath="..\..\src\game\Language.h">
+				RelativePath="..\..\src\game\Language.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\tools.cpp">
+				RelativePath="..\..\src\game\tools.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\Tools.h">
+				RelativePath="..\..\src\game\Tools.h"
+				>
 			</File>
 		</Filter>
 		<Filter
 			Name="References"
-			Filter="">
+			>
 			<File
-				RelativePath="..\..\src\game\FollowerReference.cpp">
+				RelativePath="..\..\src\game\FollowerReference.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\FollowerReference.h">
+				RelativePath="..\..\src\game\FollowerReference.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\FollowerRefManager.h">
+				RelativePath="..\..\src\game\FollowerRefManager.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\GroupReference.cpp">
+				RelativePath="..\..\src\game\GroupReference.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\GroupReference.h">
+				RelativePath="..\..\src\game\GroupReference.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\GroupRefManager.h">
+				RelativePath="..\..\src\game\GroupRefManager.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\HostilRefManager.cpp">
+				RelativePath="..\..\src\game\HostilRefManager.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\HostilRefManager.h">
+				RelativePath="..\..\src\game\HostilRefManager.h"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\ThreatManager.cpp">
+				RelativePath="..\..\src\game\ThreatManager.cpp"
+				>
 			</File>
 			<File
-				RelativePath="..\..\src\game\ThreatManager.h">
+				RelativePath="..\..\src\game\ThreatManager.h"
+				>
 			</File>
 		</Filter>
+		<Filter
+			Name="IRC"
+			>
+			<File
+				RelativePath="..\..\src\game\IRCClient.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\IRCClient.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\IRCCmd.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\IRCCmd.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\IRCCmde.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\IRCConf.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\IRCFunc.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\IRCIO.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\IRCSock.cpp"
+				>
+			</File>
+		</Filter>
 	</Files>
 	<Globals>
 	</Globals>
Index: win/VC80/game.vcproj
===================================================================
--- win/VC80/game.vcproj	(revision 4946)
+++ win/VC80/game.vcproj	(working copy)
@@ -1,7 +1,7 @@
 <?xml version="1.0" encoding="Windows-1252"?>
 <VisualStudioProject
 	ProjectType="Visual C++"
-	Version="8,00"
+	Version="8.00"
 	Name="game"
 	ProjectGUID="{1DC6C4DA-A028-41F3-877D-D5400C594F88}"
 	RootNamespace="game"
@@ -1088,6 +1088,46 @@
 				>
 			</File>
 		</Filter>
+		<Filter
+			Name="IRC"
+			>
+			<File
+				RelativePath="..\..\src\game\IRCClient.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\IRCClient.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\IRCCmd.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\IRCCmd.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\IRCCmde.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\IRCConf.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\IRCFunc.h"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\IRCIO.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\..\src\game\IRCSock.cpp"
+				>
+			</File>
+		</Filter>
 	</Files>
 	<Globals>
 	</Globals>
